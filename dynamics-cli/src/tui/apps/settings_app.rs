//! Settings TUI application for managing options

use crate::config::options::{OptionDefinition, OptionType, OptionValue};
use crate::tui::{
    app::App,
    command::Command,
    element::{Element, FocusId, ColumnBuilder, RowBuilder},
    state::{config::RuntimeConfig, theme::Theme},
    subscription::Subscription,
    widgets::list::{ListItem, ListState},
    LayeredView, LayoutConstraint,
};
use crate::{col, row, use_constraints, spacer};
use ratatui::text::{Line, Span};
use ratatui::style::Style;
use ratatui::prelude::Stylize;

#[derive(Debug, Clone)]
pub struct State {
    // View mode
    view_mode: ViewMode,

    // Navigation
    namespaces: Vec<String>,
    namespace_list_state: ListState,
    selected_namespace: usize,

    // Options for current namespace (auto-generated view)
    current_options: Vec<OptionDefinition>,
    option_list_state: ListState,
    selected_option: usize,

    // Current values
    values: std::collections::HashMap<String, OptionValue>,

    // Editing state (auto-generated view)
    editing: Option<EditingState>,
    edit_input_state: crate::tui::widgets::TextInputState,
    edit_select_state: crate::tui::widgets::SelectState,
    error: Option<String>,

    // Theme editor state (theme view)
    themes: std::collections::HashMap<String, crate::tui::Theme>,
    theme_select_state: crate::tui::widgets::SelectState,
    selected_theme_idx: usize,
    active_theme_name: String,
    creating_theme: bool,
    create_theme_input: String,
    create_theme_input_state: crate::tui::widgets::TextInputState,
    editing_color: Option<EditingColor>,
    color_picker_state: crate::tui::widgets::ColorPickerState,

    // Keybind editor state (keybind view)
    keybinds: std::collections::HashMap<String, crate::tui::KeyBinding>,
    keybind_actions: Vec<String>,
    selected_keybind_idx: usize,
    capturing_keybind: Option<String>,  // Action name being edited
    captured_key: Option<crate::tui::KeyBinding>,  // Captured keybind
    keybind_app_select_state: crate::tui::widgets::SelectState,
    selected_keybind_app_idx: usize,
    keybind_apps: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum ViewMode {
    AutoGenerated,  // Normal options list
    ThemeEditor,    // Custom theme UI
    KeybindEditor,  // Custom keybind UI
}

#[derive(Debug, Clone)]
struct EditingColor {
    theme_name: String,
    color_name: String,
}

#[derive(Debug, Clone)]
enum EditingState {
    TextInput {
        key: String,
        input: String,
    },
    Select {
        key: String,
        options: Vec<String>,
    },
}

#[derive(Debug, Clone)]
pub enum Msg {
    // Navigation
    SelectNamespace(usize),
    SelectOption(usize),
    NamespaceListNavigate(crossterm::event::KeyCode),
    OptionListNavigate(crossterm::event::KeyCode),

    // Value loading
    ValuesLoaded(Result<std::collections::HashMap<String, OptionValue>, String>),

    // Editing (auto-generated view)
    StartEdit,
    EditInputEvent(crate::tui::widgets::TextInputEvent),
    EditSelectEvent(crate::tui::widgets::SelectEvent),
    SaveValue,
    CancelEdit,
    ValueSaved(Result<(), String>),

    // Toggle boolean
    ToggleBool(String),
    BoolToggled(Result<(), String>),

    // Runtime config reload
    ConfigReloaded(Result<(), String>),

    // Theme editor
    ThemesLoaded(std::collections::HashMap<String, crate::tui::Theme>),
    ThemeSelectEvent(crate::tui::widgets::SelectEvent),
    ActivateSelectedTheme,
    ActivateTheme(String),
    ThemeActivated(Result<String, String>),
    CreateTheme,
    CreateThemeInput(crate::tui::widgets::TextInputEvent),
    SubmitCreateTheme,
    CancelCreateTheme,
    CreateThemeCompleted(Result<String, String>),
    DeleteSelectedTheme,
    ConfirmDeleteTheme,
    CancelDeleteTheme,
    DeleteThemeCompleted(Result<String, String>),
    EditThemeColor(String, String),  // theme_name, color_name
    StartEditingColor(String, String, ratatui::style::Color),  // theme_name, color_name, color
    ColorPickerEvent(crate::tui::widgets::ColorPickerEvent),
    CancelEditColor,
    SaveColor,
    ColorSaved(Result<(), String>),

    // Keybind editor
    KeybindsLoaded(std::collections::HashMap<String, crate::tui::KeyBinding>),
    KeybindAppSelectEvent(crate::tui::widgets::SelectEvent),
    EditKeybind(String),  // action name
    CaptureKey(crossterm::event::KeyEvent),
    SaveKeybind,
    CancelCaptureKeybind,
    KeybindSaved(Result<(), String>),
    ResetKeybinds,
    ResetKeybindsCompleted(Result<(), String>),
}

impl Default for State {
    fn default() -> Self {
        use crate::tui::widgets::ColorPickerMode;
        use ratatui::style::Color;

        Self {
            view_mode: ViewMode::AutoGenerated,
            namespaces: Vec::new(),
            namespace_list_state: ListState::with_selection(),
            selected_namespace: 0,
            current_options: Vec::new(),
            option_list_state: ListState::with_selection(),
            selected_option: 0,
            values: std::collections::HashMap::new(),
            editing: None,
            edit_input_state: crate::tui::widgets::TextInputState::new(),
            edit_select_state: crate::tui::widgets::SelectState::new(),
            error: None,
            themes: std::collections::HashMap::new(),
            theme_select_state: crate::tui::widgets::SelectState::new(),
            selected_theme_idx: 0,
            active_theme_name: "mocha".to_string(),
            creating_theme: false,
            create_theme_input: String::new(),
            create_theme_input_state: crate::tui::widgets::TextInputState::new(),
            editing_color: None,
            color_picker_state: crate::tui::widgets::ColorPickerState::from_color(
                Color::Rgb(180, 190, 254),
                ColorPickerMode::HSL
            ),
            keybinds: std::collections::HashMap::new(),
            keybind_actions: Vec::new(),
            selected_keybind_idx: 0,
            capturing_keybind: None,
            captured_key: None,
            keybind_app_select_state: crate::tui::widgets::SelectState::new(),
            selected_keybind_app_idx: 0,
            keybind_apps: Vec::new(),
        }
    }
}

impl State {
    /// Get theme names as a sorted vector (for UI display)
    fn theme_names(&self) -> Vec<String> {
        let mut names: Vec<String> = self.themes.keys().cloned().collect();
        names.sort();
        names
    }
}

impl crate::tui::AppState for State {}

impl ListItem for String {
    type Msg = Msg;

    fn to_element(&self, is_selected: bool, _is_hovered: bool) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        let (fg_color, bg_style) = if is_selected {
            (theme.accent_primary, Some(Style::default().bg(theme.bg_surface)))
        } else {
            (theme.text_primary, None)
        };

        let mut builder = Element::styled_text(Line::from(vec![
            Span::styled(format!("  {}", self), Style::default().fg(fg_color)),
        ]));

        if let Some(bg) = bg_style {
            builder = builder.background(bg);
        }

        builder.build()
    }
}

// Wrapper to display option with its current value
#[derive(Clone)]
struct OptionWithValue {
    definition: OptionDefinition,
    value: OptionValue,
    max_name_width: usize,
}

impl ListItem for OptionWithValue {
    type Msg = Msg;

    fn to_element(&self, is_selected: bool, _is_hovered: bool) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        let (name_color, value_color, bg_style) = if is_selected {
            (theme.accent_primary, theme.accent_tertiary, Some(Style::default().bg(theme.bg_surface)))
        } else {
            (theme.text_primary, theme.text_secondary, None)
        };

        // Format the value based on type
        let value_str = match &self.value {
            OptionValue::Bool(v) => v.to_string(),
            OptionValue::Int(v) => v.to_string(),
            OptionValue::UInt(v) => v.to_string(),
            OptionValue::Float(v) => format!("{:.2}", v),
            OptionValue::String(v) => format!("\"{}\"", v),
        };

        // Pad the name to align values in a column
        let padded_name = format!("  {:width$}", self.definition.display_name, width = self.max_name_width + 2);

        let mut builder = Element::styled_text(Line::from(vec![
            Span::styled(padded_name, Style::default().fg(name_color)),
            Span::styled(value_str, Style::default().fg(value_color)),
        ]));

        if let Some(bg) = bg_style {
            builder = builder.background(bg);
        }

        builder.build()
    }
}

impl App for SettingsApp {
    type State = State;
    type Msg = Msg;
    type InitParams = ();

    fn init(_params: ()) -> (State, Command<Msg>) {
        let mut state = State::default();

        // Load namespaces
        let registry = crate::options_registry();
        state.namespaces = registry.namespaces();

        // Check if first namespace is "theme" and set up accordingly
        let mut commands = vec![
            Command::perform(
                async {
                    let config = crate::global_config();
                    let mut values = std::collections::HashMap::new();

                    for def in crate::options_registry().list_all() {
                        if let Ok(value) = config.options.get(&def.key).await {
                            values.insert(def.key.clone(), value);
                        }
                    }

                    Ok(values)
                },
                Msg::ValuesLoaded,
            ),
            Command::set_focus(FocusId::new("namespace-list")),
        ];

        // Load options for first namespace
        if !state.namespaces.is_empty() {
            let first_namespace = &state.namespaces[0];
            if first_namespace == "theme" {
                state.view_mode = ViewMode::ThemeEditor;
                // Load all themes with their full data
                commands.push(Command::perform(
                    async {
                        use crate::config::options::registrations::themes;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let theme_names = themes::list_themes(&registry);
                        crate::tui::state::config::load_all_themes(&config.options, theme_names).await
                    },
                    Msg::ThemesLoaded
                ));
            } else if first_namespace == "keybind" {
                state.view_mode = ViewMode::KeybindEditor;
                // Load all keybinds
                commands.push(Command::perform(
                    async {
                        use crate::config::options::registrations::keybinds;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let mut keybinds = std::collections::HashMap::new();

                        for action in keybinds::list_all_actions(&registry) {
                            let key = format!("keybind.{}", action);
                            if let Ok(keybind_str) = config.options.get_string(&key).await {
                                if let Ok(keybind) = keybind_str.parse() {
                                    keybinds.insert(action, keybind);
                                }
                            }
                        }

                        keybinds
                    },
                    Msg::KeybindsLoaded
                ));
            } else {
                let mut options = registry.list_namespace(first_namespace);
                // Filter out theme.active if in theme namespace (handled by theme editor)
                if first_namespace == "theme" {
                    options.retain(|opt| opt.local_key != "active");
                }
                state.current_options = options;
            }
        }

        (state, Command::batch(commands))
    }

    fn update(state: &mut State, msg: Msg) -> Command<Msg> {
        match msg {
            Msg::SelectNamespace(idx) => {
                if idx < state.namespaces.len() {
                    state.selected_namespace = idx;
                    state.selected_option = 0;

                    let namespace = &state.namespaces[idx];

                    // Check if this is the theme namespace - switch to theme editor
                    if namespace == "theme" {
                        state.view_mode = ViewMode::ThemeEditor;

                        // Load all themes with their full data
                        return Command::perform(
                            async {
                                use crate::config::options::registrations::themes;
                                let config = crate::global_config();
                                let registry = crate::options_registry();
                                let theme_names = themes::list_themes(&registry);
                                crate::tui::state::config::load_all_themes(&config.options, theme_names).await
                            },
                            Msg::ThemesLoaded
                        );
                    } else if namespace == "keybind" {
                        state.view_mode = ViewMode::KeybindEditor;

                        // Load all keybinds
                        return Command::perform(
                            async {
                                use crate::config::options::registrations::keybinds;
                                let config = crate::global_config();
                                let registry = crate::options_registry();
                                let mut keybinds = std::collections::HashMap::new();

                                for action in keybinds::list_all_actions(&registry) {
                                    let key = format!("keybind.{}", action);
                                    if let Ok(keybind_str) = config.options.get_string(&key).await {
                                        if let Ok(keybind) = keybind_str.parse() {
                                            keybinds.insert(action, keybind);
                                        }
                                    }
                                }

                                keybinds
                            },
                            Msg::KeybindsLoaded
                        );
                    } else {
                        state.view_mode = ViewMode::AutoGenerated;

                        // Load options for this namespace
                        let registry = crate::options_registry();
                        let mut options = registry.list_namespace(namespace);

                        // Filter out theme.active if in theme namespace (handled by theme editor)
                        if namespace == "theme" {
                            options.retain(|opt| opt.local_key != "active");
                        }

                        state.current_options = options;

                        // Focus the options list after selecting a category
                        return Command::set_focus(FocusId::new("option-list"));
                    }
                }
                Command::None
            }

            Msg::SelectOption(idx) => {
                if idx < state.current_options.len() {
                    state.selected_option = idx;

                    // Start editing this option (inline StartEdit logic)
                    if let Some(opt) = state.current_options.get(idx) {
                        match &opt.ty {
                            OptionType::Bool => {
                                // For bools, toggle immediately
                                let value = state
                                    .values
                                    .get(&opt.key)
                                    .unwrap_or(&opt.default)
                                    .as_bool()
                                    .unwrap_or(false);
                                let key = opt.key.clone();
                                return Command::perform(
                                    async move {
                                        crate::global_config()
                                            .options
                                            .set_bool(&key, !value)
                                            .await
                                            .map_err(|e| e.to_string())
                                    },
                                    Msg::BoolToggled,
                                );
                            }
                            OptionType::Enum { variants } => {
                                // Use select widget for enums
                                state.editing = Some(EditingState::Select {
                                    key: opt.key.clone(),
                                    options: variants.clone(),
                                });
                                // Reset the select state and set the current value as selected
                                let current_value = state.values.get(&opt.key).unwrap_or(&opt.default).as_string().unwrap_or_default();
                                if let Some(index) = variants.iter().position(|v| v == &current_value) {
                                    state.edit_select_state = crate::tui::widgets::SelectState::with_selected(index);
                                } else {
                                    state.edit_select_state = crate::tui::widgets::SelectState::new();
                                }
                                return Command::set_focus(FocusId::new("edit-select"));
                            }
                            OptionType::UInt { .. } | OptionType::Int { .. } | OptionType::Float { .. } | OptionType::String { .. } => {
                                // Start text input for other types
                                let current = state
                                    .values
                                    .get(&opt.key)
                                    .unwrap_or(&opt.default)
                                    .clone();
                                let input_str = match current {
                                    OptionValue::UInt(v) => v.to_string(),
                                    OptionValue::Int(v) => v.to_string(),
                                    OptionValue::Float(v) => v.to_string(),
                                    OptionValue::String(v) => v,
                                    _ => String::new(),
                                };
                                state.editing = Some(EditingState::TextInput {
                                    key: opt.key.clone(),
                                    input: input_str,
                                });
                                // Reset the text input state for fresh editing
                                state.edit_input_state = crate::tui::widgets::TextInputState::new();
                                return Command::set_focus(FocusId::new("edit-input"));
                            }
                        }
                    }
                }
                Command::None
            }

            Msg::NamespaceListNavigate(key) => {
                let visible_height = 20;
                state.namespace_list_state.handle_key(key, state.namespaces.len(), visible_height);

                // Sync the selected namespace index with the list state
                if let Some(selected) = state.namespace_list_state.selected() {
                    if selected != state.selected_namespace && selected < state.namespaces.len() {
                        // Delegate to SelectNamespace to handle view mode switching
                        return Self::update(state, Msg::SelectNamespace(selected));
                    }
                }

                Command::None
            }

            Msg::OptionListNavigate(key) => {
                let visible_height = 20;
                state.option_list_state.handle_key(key, state.current_options.len(), visible_height);

                // Sync the selected option index with the list state
                if let Some(selected) = state.option_list_state.selected() {
                    state.selected_option = selected;
                }

                Command::None
            }

            Msg::ValuesLoaded(Ok(values)) => {
                state.values = values;
                Command::None
            }

            Msg::ValuesLoaded(Err(e)) => {
                state.error = Some(e);
                Command::None
            }

            Msg::StartEdit => {
                if let Some(opt) = state.current_options.get(state.selected_option) {
                    match &opt.ty {
                        OptionType::Bool => {
                            // For bools, toggle immediately
                            let value = state
                                .values
                                .get(&opt.key)
                                .unwrap_or(&opt.default)
                                .as_bool()
                                .unwrap_or(false);
                            let key = opt.key.clone();
                            return Command::perform(
                                async move {
                                    crate::global_config()
                                        .options
                                        .set_bool(&key, !value)
                                        .await
                                        .map_err(|e| e.to_string())
                                },
                                Msg::BoolToggled,
                            );
                        }
                        OptionType::Enum { variants } => {
                            // Use select widget for enums
                            state.editing = Some(EditingState::Select {
                                key: opt.key.clone(),
                                options: variants.clone(),
                            });
                            // Reset the select state and set the current value as selected
                            let current_value = state.values.get(&opt.key).unwrap_or(&opt.default).as_string().unwrap_or_default();
                            if let Some(index) = variants.iter().position(|v| v == &current_value) {
                                state.edit_select_state = crate::tui::widgets::SelectState::with_selected(index);
                            } else {
                                state.edit_select_state = crate::tui::widgets::SelectState::new();
                            }
                            return Command::set_focus(FocusId::new("edit-select"));
                        }
                        OptionType::UInt { .. } | OptionType::Int { .. } | OptionType::Float { .. } | OptionType::String { .. } => {
                            // Start text input for other types
                            let current = state
                                .values
                                .get(&opt.key)
                                .unwrap_or(&opt.default)
                                .clone();
                            let input_str = match current {
                                OptionValue::UInt(v) => v.to_string(),
                                OptionValue::Int(v) => v.to_string(),
                                OptionValue::Float(v) => v.to_string(),
                                OptionValue::String(v) => v,
                                _ => String::new(),
                            };
                            state.editing = Some(EditingState::TextInput {
                                key: opt.key.clone(),
                                input: input_str,
                            });
                            // Reset the text input state for fresh editing
                            state.edit_input_state = crate::tui::widgets::TextInputState::new();
                            return Command::set_focus(FocusId::new("edit-input"));
                        }
                    }
                }
                Command::None
            }

            Msg::ToggleBool(key) => {
                let value = state
                    .values
                    .get(&key)
                    .and_then(|v| v.as_bool().ok())
                    .unwrap_or(false);

                Command::perform(
                    async move {
                        crate::global_config()
                            .options
                            .set_bool(&key, !value)
                            .await
                            .map_err(|e| e.to_string())
                    },
                    Msg::BoolToggled,
                )
            }

            Msg::BoolToggled(Ok(())) => {
                // Reload values and runtime config
                Command::batch(vec![
                    Command::perform(
                        async {
                            let config = crate::global_config();
                            let mut values = std::collections::HashMap::new();

                            for def in crate::options_registry().list_all() {
                                if let Ok(value) = config.options.get(&def.key).await {
                                    values.insert(def.key.clone(), value);
                                }
                            }

                            Ok(values)
                        },
                        Msg::ValuesLoaded,
                    ),
                    Command::perform(
                        async {
                            let new_config = crate::tui::state::RuntimeConfig::load_from_options().await
                                .map_err(|e| e.to_string())?;
                            crate::reload_runtime_config(new_config);
                            Ok(())
                        },
                        Msg::ConfigReloaded,
                    ),
                ])
            }

            Msg::BoolToggled(Err(e)) => {
                state.error = Some(e);
                Command::None
            }

            Msg::EditInputEvent(event) => {
                use crate::tui::widgets::TextInputEvent;

                match event {
                    TextInputEvent::Submit => {
                        // Same as SaveValue
                        if let Some(EditingState::TextInput { key, input }) = &state.editing {
                            let key = key.clone();
                            let input = input.clone();

                            let opt = state.current_options.iter().find(|o| o.key == key).cloned();
                            if let Some(opt) = opt {
                                state.editing = None;

                                return Command::perform(
                                    async move {
                                        let value = match opt.ty {
                                            OptionType::UInt { .. } => {
                                                let parsed = input.parse::<u64>()
                                                    .map_err(|e| format!("Invalid number: {}", e))?;
                                                OptionValue::UInt(parsed)
                                            }
                                            OptionType::Int { .. } => {
                                                let parsed = input.parse::<i64>()
                                                    .map_err(|e| format!("Invalid number: {}", e))?;
                                                OptionValue::Int(parsed)
                                            }
                                            OptionType::Float { .. } => {
                                                let parsed = input.parse::<f64>()
                                                    .map_err(|e| format!("Invalid number: {}", e))?;
                                                OptionValue::Float(parsed)
                                            }
                                            OptionType::String { .. } | OptionType::Enum { .. } => {
                                                OptionValue::String(input)
                                            }
                                            _ => return Err("Unsupported type".to_string()),
                                        };

                                        crate::global_config()
                                            .options
                                            .set(&key, value)
                                            .await
                                            .map_err(|e| e.to_string())
                                    },
                                    Msg::ValueSaved,
                                );
                            }
                        }
                        Command::None
                    }
                    TextInputEvent::Changed(key_code) => {
                        if let Some(EditingState::TextInput { input, .. }) = &mut state.editing {
                            // Use TextInputState's handle_key to process the key and get new value
                            if let Some(new_value) = state.edit_input_state.handle_key(key_code, input, None) {
                                *input = new_value;
                            }
                        }
                        Command::None
                    }
                }
            }

            Msg::EditSelectEvent(event) => {
                use crate::tui::widgets::SelectEvent;
                use crossterm::event::KeyCode;

                // Let SelectState handle the event
                if let Some(EditingState::Select { key, options }) = &state.editing {
                    // Update option count before handling event
                    state.edit_select_state.update_option_count(options.len());

                    // Handle Enter key to toggle when closed
                    match event {
                        SelectEvent::Navigate(KeyCode::Enter) if !state.edit_select_state.is_open() => {
                            // Toggle open when closed
                            state.edit_select_state.toggle();
                            return Command::None;
                        }
                        SelectEvent::Navigate(KeyCode::Enter) if state.edit_select_state.is_open() => {
                            // Select highlighted item when open
                            state.edit_select_state.select_highlighted();
                            let selected_idx = state.edit_select_state.selected();

                            if let Some(selected_value) = options.get(selected_idx) {
                                let key = key.clone();
                                let value = selected_value.clone();
                                state.editing = None;

                                return Command::perform(
                                    async move {
                                        crate::global_config()
                                            .options
                                            .set(&key, OptionValue::String(value))
                                            .await
                                            .map_err(|e| e.to_string())
                                    },
                                    Msg::ValueSaved,
                                );
                            }
                        }
                        SelectEvent::Navigate(KeyCode::Esc) => {
                            // Close dropdown or cancel editing
                            if state.edit_select_state.is_open() {
                                state.edit_select_state.close();
                            } else {
                                state.editing = None;
                            }
                            return Command::None;
                        }
                        _ => {
                            // Handle other navigation events
                            if let Some(selected_idx) = state.edit_select_state.handle_event(event) {
                                // A value was selected via click
                                if let Some(selected_value) = options.get(selected_idx) {
                                    let key = key.clone();
                                    let value = selected_value.clone();
                                    state.editing = None;

                                    return Command::perform(
                                        async move {
                                            crate::global_config()
                                                .options
                                                .set(&key, OptionValue::String(value))
                                                .await
                                                .map_err(|e| e.to_string())
                                        },
                                        Msg::ValueSaved,
                                    );
                                }
                            }
                        }
                    }
                }
                Command::None
            }

            Msg::SaveValue => {
                if let Some(EditingState::TextInput { key, input }) = &state.editing {
                    let key = key.clone();
                    let input = input.clone();

                    let opt = state.current_options.iter().find(|o| o.key == key).cloned();
                    if let Some(opt) = opt {
                        state.editing = None;

                        return Command::perform(
                            async move {
                                let value = match opt.ty {
                                    OptionType::UInt { .. } => {
                                        let parsed = input.parse::<u64>()
                                            .map_err(|e| format!("Invalid number: {}", e))?;
                                        OptionValue::UInt(parsed)
                                    }
                                    OptionType::String { .. } | OptionType::Enum { .. } => {
                                        OptionValue::String(input)
                                    }
                                    _ => return Err("Unsupported type".to_string()),
                                };

                                crate::global_config()
                                    .options
                                    .set(&key, value)
                                    .await
                                    .map_err(|e| e.to_string())
                            },
                            Msg::ValueSaved,
                        );
                    }
                }
                Command::None
            }

            Msg::CancelEdit => {
                state.editing = None;
                Command::None
            }

            Msg::ValueSaved(Ok(())) => {
                state.error = None;
                // Reload values and runtime config
                Command::batch(vec![
                    Command::perform(
                        async {
                            let config = crate::global_config();
                            let mut values = std::collections::HashMap::new();

                            for def in crate::options_registry().list_all() {
                                if let Ok(value) = config.options.get(&def.key).await {
                                    values.insert(def.key.clone(), value);
                                }
                            }

                            Ok(values)
                        },
                        Msg::ValuesLoaded,
                    ),
                    Command::perform(
                        async {
                            let new_config = crate::tui::state::RuntimeConfig::load_from_options().await
                                .map_err(|e| e.to_string())?;
                            crate::reload_runtime_config(new_config);
                            Ok(())
                        },
                        Msg::ConfigReloaded,
                    ),
                ])
            }

            Msg::ValueSaved(Err(e)) => {
                state.error = Some(e);
                state.editing = None;
                Command::None
            }

            Msg::ConfigReloaded(Ok(())) => {
                log::debug!("Runtime config reloaded successfully");
                Command::None
            }

            Msg::ConfigReloaded(Err(e)) => {
                log::error!("Failed to reload runtime config: {}", e);
                state.error = Some(format!("Failed to reload config: {}", e));
                Command::None
            }

            // Theme editor messages
            Msg::ThemesLoaded(themes) => {
                state.themes = themes;
                state.selected_theme_idx = 0;

                // Initialize select state with theme count
                let theme_count = state.themes.len();
                if theme_count > 0 {
                    state.theme_select_state = crate::tui::widgets::SelectState::with_selected(0);
                }

                // Load active theme name
                let cmd = Command::perform(
                    async {
                        let config = crate::global_config();
                        config.options.get_string("theme.active").await
                            .unwrap_or_else(|_| "mocha".to_string())
                    },
                    |name| Msg::ThemeActivated(Ok(name))
                );

                Command::batch(vec![
                    cmd,
                    Command::set_focus(FocusId::new("theme-select"))
                ])
            }

            Msg::ThemeSelectEvent(event) => {
                use crate::tui::widgets::SelectEvent;
                use crossterm::event::KeyCode;

                // Update option count before handling event
                let theme_count = state.themes.len();
                state.theme_select_state.update_option_count(theme_count);

                match event {
                    SelectEvent::Navigate(KeyCode::Enter) if !state.theme_select_state.is_open() => {
                        // Open dropdown when closed
                        state.theme_select_state.toggle();
                        Command::None
                    }
                    SelectEvent::Navigate(KeyCode::Enter) if state.theme_select_state.is_open() => {
                        // Select highlighted item when open
                        state.theme_select_state.select_highlighted();
                        let selected_idx = state.theme_select_state.selected();
                        state.selected_theme_idx = selected_idx;

                        // Activate the selected theme
                        let theme_names = state.theme_names();
                        if let Some(theme_name) = theme_names.get(selected_idx) {
                            return Self::update(state, Msg::ActivateTheme(theme_name.clone()));
                        }
                        Command::None
                    }
                    SelectEvent::Navigate(KeyCode::Esc) => {
                        // Close dropdown
                        if state.theme_select_state.is_open() {
                            state.theme_select_state.close();
                        }
                        Command::None
                    }
                    SelectEvent::Select(idx) => {
                        // Handle click selection
                        state.selected_theme_idx = idx;
                        let theme_names = state.theme_names();
                        if let Some(theme_name) = theme_names.get(idx) {
                            return Self::update(state, Msg::ActivateTheme(theme_name.clone()));
                        }
                        Command::None
                    }
                    _ => {
                        // Handle other navigation (Up/Down arrows)
                        state.theme_select_state.handle_event(event);
                        Command::None
                    }
                }
            }

            Msg::ActivateSelectedTheme => {
                // Get the selected theme name and dispatch ActivateTheme
                let theme_names = state.theme_names();
                if let Some(theme_name) = theme_names.get(state.selected_theme_idx) {
                    return Self::update(state, Msg::ActivateTheme(theme_name.clone()));
                }
                Command::None
            }

            Msg::ActivateTheme(theme_name) => {
                Command::perform(
                    async move {
                        let config = crate::global_config();
                        config.options.set_string("theme.active", theme_name.clone()).await
                            .map_err(|e| e.to_string())?;

                        // Reload runtime config
                        let new_config = RuntimeConfig::load_from_options().await
                            .map_err(|e| e.to_string())?;
                        crate::reload_runtime_config(new_config);

                        Ok(theme_name)
                    },
                    Msg::ThemeActivated
                )
            }

            Msg::ThemeActivated(Ok(name)) => {
                state.active_theme_name = name.clone();

                // Update select state to show the active theme
                let theme_names = state.theme_names();
                if let Some(idx) = theme_names.iter().position(|n| n == &name) {
                    state.selected_theme_idx = idx;
                    state.theme_select_state = crate::tui::widgets::SelectState::with_selected(idx);
                }

                Command::None
            }

            Msg::ThemeActivated(Err(e)) => {
                state.error = Some(format!("Failed to activate theme: {}", e));
                Command::None
            }

            Msg::CreateTheme => {
                state.creating_theme = true;
                state.create_theme_input.clear();
                state.create_theme_input_state = crate::tui::widgets::TextInputState::new();
                Command::set_focus(FocusId::new("create-theme-input"))
            }

            Msg::CreateThemeInput(event) => {
                use crate::tui::widgets::TextInputEvent;
                match event {
                    TextInputEvent::Changed(key_code) => {
                        // Use TextInputState's handle_key to process the key and get new value
                        if let Some(new_value) = state.create_theme_input_state.handle_key(
                            key_code,
                            &state.create_theme_input,
                            None
                        ) {
                            state.create_theme_input = new_value;
                        }
                        Command::None
                    }
                    TextInputEvent::Submit => {
                        Self::update(state, Msg::SubmitCreateTheme)
                    }
                }
            }

            Msg::CancelCreateTheme => {
                state.creating_theme = false;
                Command::None
            }

            Msg::SubmitCreateTheme => {
                let new_theme_name = state.create_theme_input.trim().to_string();

                // Validate theme name
                if new_theme_name.is_empty() {
                    state.error = Some("Theme name cannot be empty".to_string());
                    return Command::None;
                }

                if state.themes.contains_key(&new_theme_name) {
                    state.error = Some(format!("Theme '{}' already exists", new_theme_name));
                    return Command::None;
                }

                // Copy colors from active theme
                let source_theme = state.active_theme_name.clone();
                state.creating_theme = false;

                Command::perform(
                    async move {
                        use crate::tui::state::theme::COLOR_NAMES;
                        let config = crate::global_config();

                        // Copy all 21 colors from source theme to new theme
                        for color_name in COLOR_NAMES {
                            let source_key = format!("theme.{}.{}", source_theme, color_name);
                            let dest_key = format!("theme.{}.{}", new_theme_name, color_name);

                            let value = config.options.get_string(&source_key).await
                                .map_err(|e| format!("Failed to read {}: {}", source_key, e))?;

                            config.options.set_string(&dest_key, value).await
                                .map_err(|e| format!("Failed to write {}: {}", dest_key, e))?;
                        }

                        Ok(new_theme_name)
                    },
                    Msg::CreateThemeCompleted
                )
            }

            Msg::CreateThemeCompleted(Ok(theme_name)) => {
                // Reload all themes
                Command::perform(
                    async {
                        use crate::config::options::registrations::themes;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let theme_names = themes::list_themes(&registry);
                        crate::tui::state::config::load_all_themes(&config.options, theme_names).await
                    },
                    Msg::ThemesLoaded
                )
            }

            Msg::CreateThemeCompleted(Err(e)) => {
                state.error = Some(format!("Failed to create theme: {}", e));
                Command::None
            }

            Msg::DeleteSelectedTheme => {
                let theme_names = state.theme_names();
                if let Some(theme_name) = theme_names.get(state.selected_theme_idx) {
                    // Validate
                    if theme_name == &state.active_theme_name {
                        state.error = Some("Cannot delete the active theme".to_string());
                        return Command::None;
                    }

                    if state.themes.len() <= 1 {
                        state.error = Some("Cannot delete the last theme".to_string());
                        return Command::None;
                    }

                    // Show confirmation - just proceed to confirm immediately for now
                    // (in a more complete implementation, you'd show a modal)
                    return Self::update(state, Msg::ConfirmDeleteTheme);
                }
                Command::None
            }

            Msg::ConfirmDeleteTheme => {
                let theme_names = state.theme_names();
                if let Some(theme_name) = theme_names.get(state.selected_theme_idx).cloned() {
                    Command::perform(
                        async move {
                            use crate::tui::state::theme::COLOR_NAMES;
                            let config = crate::global_config();

                            // Delete all 21 color options for this theme
                            for color_name in COLOR_NAMES {
                                let key = format!("theme.{}.{}", theme_name, color_name);
                                config.options.delete(&key).await
                                    .map_err(|e| format!("Failed to delete {}: {}", key, e))?;
                            }

                            Ok(theme_name)
                        },
                        Msg::DeleteThemeCompleted
                    )
                } else {
                    Command::None
                }
            }

            Msg::CancelDeleteTheme => {
                // For now, this is unused since we don't have a confirmation modal yet
                Command::None
            }

            Msg::DeleteThemeCompleted(Ok(_theme_name)) => {
                // Reload all themes
                Command::perform(
                    async {
                        use crate::config::options::registrations::themes;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let theme_names = themes::list_themes(&registry);
                        crate::tui::state::config::load_all_themes(&config.options, theme_names).await
                    },
                    Msg::ThemesLoaded
                )
            }

            Msg::DeleteThemeCompleted(Err(e)) => {
                state.error = Some(format!("Failed to delete theme: {}", e));
                Command::None
            }

            Msg::EditThemeColor(theme_name, color_name) => {
                // Load current color value and open color picker
                Command::perform(
                    async move {
                        use crate::tui::color::hex_to_color;
                        let config = crate::global_config();
                        let key = format!("theme.{}.{}", theme_name, color_name);
                        let hex = config.options.get_string(&key).await
                            .map_err(|e| e.to_string())?;
                        let color = hex_to_color(&hex)
                            .map_err(|e| e.to_string())?;
                        Ok((theme_name, color_name, color))
                    },
                    |result: Result<(String, String, ratatui::style::Color), String>| match result {
                        Ok((theme, color_key, color_value)) => {
                            // Set up editing state
                            Msg::StartEditingColor(theme, color_key, color_value)
                        }
                        Err(e) => {
                            log::error!("Failed to load color: {}", e);
                            Msg::CancelEdit
                        }
                    }
                )
            }

            Msg::StartEditingColor(theme_name, color_name, color) => {
                use crate::tui::widgets::ColorPickerMode;
                state.editing_color = Some(EditingColor {
                    theme_name,
                    color_name,
                });
                state.color_picker_state = crate::tui::widgets::ColorPickerState::from_color(
                    color,
                    ColorPickerMode::HSL
                );
                Command::set_focus(FocusId::new("color-picker"))
            }

            Msg::ColorPickerEvent(event) => {
                use crate::tui::widgets::ColorPickerEvent;
                match event {
                    ColorPickerEvent::Changed(key_code) => {
                        // Let the state handle the key and update itself
                        state.color_picker_state.handle_key(key_code);
                        Command::None
                    }
                    ColorPickerEvent::Submitted(_) => {
                        // Save the color
                        Self::update(state, Msg::SaveColor)
                    }
                }
            }

            Msg::CancelEditColor => {
                state.editing_color = None;
                Command::None
            }

            Msg::SaveColor => {
                if let Some(editing) = &state.editing_color {
                    use crate::tui::color::color_to_hex;
                    let theme_name = editing.theme_name.clone();
                    let color_name = editing.color_name.clone();
                    let color = state.color_picker_state.color();
                    let hex = color_to_hex(color);

                    Command::perform(
                        async move {
                            let config = crate::global_config();
                            let key = format!("theme.{}.{}", theme_name, color_name);
                            config.options.set_string(&key, hex).await
                                .map_err(|e| e.to_string())?;

                            // If editing active theme, reload runtime config
                            let active = config.options.get_string("theme.active").await
                                .map_err(|e| e.to_string())?;
                            if active == theme_name {
                                let new_config = RuntimeConfig::load_from_options().await
                                    .map_err(|e| e.to_string())?;
                                crate::reload_runtime_config(new_config);
                            }

                            Ok(())
                        },
                        Msg::ColorSaved
                    )
                } else {
                    Command::None
                }
            }

            Msg::ColorSaved(Ok(())) => {
                state.editing_color = None;
                Command::None
            }

            Msg::ColorSaved(Err(e)) => {
                state.error = Some(format!("Failed to save color: {}", e));
                Command::None
            }

            // Keybind editor messages
            Msg::KeybindsLoaded(keybinds) => {
                use crate::config::options::registrations::keybinds;
                let registry = crate::options_registry();

                state.keybinds = keybinds;
                state.keybind_actions = keybinds::list_all_actions(&registry);
                state.selected_keybind_idx = 0;

                // Populate app list for filtering (no "All" option)
                let old_apps = std::mem::take(&mut state.keybind_apps);
                state.keybind_apps = keybinds::list_apps(&registry);

                // Preserve the selected app if it still exists, otherwise default to "global" or first app
                let preserved_app = old_apps.get(state.selected_keybind_app_idx);
                let default_idx = if let Some(app) = preserved_app {
                    // Try to find the previously selected app in the new list
                    state.keybind_apps.iter().position(|a| a == app)
                        .unwrap_or_else(|| {
                            // Fall back to "global" or first app
                            state.keybind_apps.iter().position(|a| a == "global").unwrap_or(0)
                        })
                } else {
                    // First load - default to "global" if it exists, otherwise first app
                    state.keybind_apps.iter().position(|app| app == "global").unwrap_or(0)
                };

                state.selected_keybind_app_idx = default_idx;
                state.keybind_app_select_state = crate::tui::widgets::SelectState::with_selected(default_idx);

                Command::None
            }

            Msg::KeybindAppSelectEvent(event) => {
                use crate::tui::widgets::SelectEvent;
                use crossterm::event::KeyCode;

                // Update option count before handling event
                state.keybind_app_select_state.update_option_count(state.keybind_apps.len());

                match event {
                    SelectEvent::Navigate(KeyCode::Enter) if !state.keybind_app_select_state.is_open() => {
                        state.keybind_app_select_state.toggle();
                        Command::None
                    }
                    SelectEvent::Navigate(KeyCode::Enter) if state.keybind_app_select_state.is_open() => {
                        state.keybind_app_select_state.select_highlighted();
                        state.selected_keybind_app_idx = state.keybind_app_select_state.selected();
                        Command::None
                    }
                    SelectEvent::Navigate(KeyCode::Esc) => {
                        if state.keybind_app_select_state.is_open() {
                            state.keybind_app_select_state.close();
                        }
                        Command::None
                    }
                    SelectEvent::Select(idx) => {
                        state.selected_keybind_app_idx = idx;
                        Command::None
                    }
                    _ => {
                        state.keybind_app_select_state.handle_event(event);
                        Command::None
                    }
                }
            }

            Msg::EditKeybind(action) => {
                state.capturing_keybind = Some(action);
                state.captured_key = None;
                Command::set_focus(FocusId::new("keybind-capture"))
            }

            Msg::CaptureKey(key_event) => {
                // Store the captured key
                state.captured_key = Some(crate::tui::KeyBinding::with_modifiers(
                    key_event.code,
                    key_event.modifiers
                ));
                Command::None
            }

            Msg::SaveKeybind => {
                if let (Some(action), Some(keybind)) = (&state.capturing_keybind, &state.captured_key) {
                    let action = action.clone();
                    let keybind_str = keybind.to_string();

                    state.capturing_keybind = None;
                    state.captured_key = None;

                    Command::perform(
                        async move {
                            let config = crate::global_config();
                            let key = format!("keybind.{}", action);
                            config.options.set_string(&key, keybind_str).await
                                .map_err(|e| e.to_string())?;

                            // Reload runtime config
                            let new_config = RuntimeConfig::load_from_options().await
                                .map_err(|e| e.to_string())?;
                            crate::reload_runtime_config(new_config);

                            Ok(())
                        },
                        Msg::KeybindSaved
                    )
                } else {
                    Command::None
                }
            }

            Msg::CancelCaptureKeybind => {
                state.capturing_keybind = None;
                state.captured_key = None;
                Command::None
            }

            Msg::KeybindSaved(Ok(())) => {
                // Reload keybinds
                Command::perform(
                    async {
                        use crate::config::options::registrations::keybinds;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let mut keybinds = std::collections::HashMap::new();

                        for action in keybinds::list_all_actions(&registry) {
                            let key = format!("keybind.{}", action);
                            if let Ok(keybind_str) = config.options.get_string(&key).await {
                                if let Ok(keybind) = keybind_str.parse() {
                                    keybinds.insert(action, keybind);
                                }
                            }
                        }

                        keybinds
                    },
                    Msg::KeybindsLoaded
                )
            }

            Msg::KeybindSaved(Err(e)) => {
                state.error = Some(format!("Failed to save keybind: {}", e));
                Command::None
            }

            Msg::ResetKeybinds => {
                Command::perform(
                    async {
                        use crate::config::options::registrations::keybinds;
                        use std::str::FromStr;
                        let config = crate::global_config();

                        // Reset to defaults (now app-scoped)
                        config.options.set_string("keybind.global.help", "F1".to_string()).await
                            .map_err(|e| e.to_string())?;
                        config.options.set_string("keybind.global.app_launcher", "Ctrl+A".to_string()).await
                            .map_err(|e| e.to_string())?;
                        config.options.set_string("keybind.global.app_overview", "Ctrl+O".to_string()).await
                            .map_err(|e| e.to_string())?;

                        // Reload runtime config
                        let new_config = RuntimeConfig::load_from_options().await
                            .map_err(|e| e.to_string())?;
                        crate::reload_runtime_config(new_config);

                        Ok(())
                    },
                    Msg::ResetKeybindsCompleted
                )
            }

            Msg::ResetKeybindsCompleted(Ok(())) => {
                // Reload keybinds
                Command::perform(
                    async {
                        use crate::config::options::registrations::keybinds;
                        let config = crate::global_config();
                        let registry = crate::options_registry();
                        let mut keybinds = std::collections::HashMap::new();

                        for action in keybinds::list_all_actions(&registry) {
                            let key = format!("keybind.{}", action);
                            if let Ok(keybind_str) = config.options.get_string(&key).await {
                                if let Ok(keybind) = keybind_str.parse() {
                                    keybinds.insert(action, keybind);
                                }
                            }
                        }

                        keybinds
                    },
                    Msg::KeybindsLoaded
                )
            }

            Msg::ResetKeybindsCompleted(Err(e)) => {
                state.error = Some(format!("Failed to reset keybinds: {}", e));
                Command::None
            }
        }
    }

    fn view(state: &mut State) -> LayeredView<Msg> {
        use_constraints!();
        let theme = &crate::global_runtime_config().theme;

        // Left sidebar: namespace list
        let namespace_list = Element::list(
            "namespace-list",
            &state.namespaces,
            &state.namespace_list_state,
            theme
        )
        .on_select(Msg::SelectNamespace)
        .on_activate(Msg::SelectNamespace)
        .on_navigate(Msg::NamespaceListNavigate)
        .build();

        let left_panel = Element::panel(namespace_list)
            .title("Categories")
            .build();

        // Right panel: depends on view mode
        let (right_panel, namespace_title) = match state.view_mode {
            ViewMode::ThemeEditor => {
                // Theme editor view
                Self::render_theme_editor(state, theme)
            }
            ViewMode::KeybindEditor => {
                // Keybind editor view
                Self::render_keybind_editor(state, theme)
            }
            ViewMode::AutoGenerated => {
                // Original auto-generated options view
                let option_list_content = if state.current_options.is_empty() {
                    Element::styled_text(Line::from(vec![
                        Span::styled("No options in this category", Style::default().fg(theme.text_tertiary))
                    ])).build()
                } else {
                    // Calculate max name width for alignment
                    let max_name_width = state.current_options.iter()
                        .map(|opt| opt.display_name.len())
                        .max()
                        .unwrap_or(0);

                    // Create wrapped options with values
                    let options_with_values: Vec<OptionWithValue> = state.current_options.iter()
                        .map(|opt| OptionWithValue {
                            value: state.values.get(&opt.key).unwrap_or(&opt.default).clone(),
                            definition: opt.clone(),
                            max_name_width,
                        })
                        .collect();

                    Element::list(
                        "option-list",
                        &options_with_values,
                        &state.option_list_state,
                        theme
                    )
                    .on_select(Msg::SelectOption)
                    .on_activate(Msg::SelectOption)
                    .on_navigate(Msg::OptionListNavigate)
                    .build()
                };

                let namespace_title = if state.selected_namespace < state.namespaces.len() {
                    format!("Options - {}", state.namespaces[state.selected_namespace])
                } else {
                    "Options".to_string()
                };

                let option_list_panel = Element::panel(option_list_content)
                    .title(&namespace_title)
                    .build();

                (option_list_panel, namespace_title)
            }
        };

        // Main layout - just the two lists side by side
        let main_ui = if let Some(error) = &state.error {
            // With error display
            let error_section = Element::container(
                Element::styled_text(Line::from(vec![
                    Span::styled(format!("Error: {}", error), Style::default().fg(theme.accent_error))
                ])).build()
            )
            .padding(1)
            .build();

            row![
                left_panel => Length(30),
                col![
                    right_panel => Fill(1),
                    error_section => Length(2),
                ] => Fill(1),
            ]
        } else {
            // Without error display
            row![
                left_panel => Length(30),
                right_panel => Fill(1),
            ]
        };

        // If editing, add a modal
        let mut view = LayeredView::new(main_ui);

        if state.editing.is_some() {
            if let Some(opt) = state.current_options.get(state.selected_option).cloned() {
                let modal = Self::render_edit_modal(state, &opt);
                view = view.with_app_modal(modal, crate::tui::Alignment::Center);
            }
        }

        // Create theme modal
        if state.creating_theme {
            let modal = Self::render_create_theme_modal(state);
            view = view.with_app_modal(modal, crate::tui::Alignment::Center);
        }

        // Color picker modal
        if state.editing_color.is_some() {
            let modal = Self::render_color_picker_modal(state);
            view = view.with_app_modal(modal, crate::tui::Alignment::Center);
        }

        // Keybind capture modal
        if state.capturing_keybind.is_some() {
            let modal = Self::render_keybind_capture_modal(state);
            view = view.with_app_modal(modal, crate::tui::Alignment::Center);
        }

        view
    }

    fn subscriptions(state: &State) -> Vec<Subscription<Msg>> {
        use crossterm::event::KeyCode;

        let mut subs = vec![];

        // If not editing, allow Enter to start editing the selected option
        if state.editing.is_none() && !state.current_options.is_empty() {
            subs.push(Subscription::keyboard(
                KeyCode::Enter,
                "Edit selected option",
                Msg::StartEdit,
            ));
        }

        // If editing, allow Escape to cancel
        if state.editing.is_some() {
            subs.push(Subscription::keyboard(
                KeyCode::Esc,
                "Cancel editing",
                Msg::CancelEdit,
            ));
        }

        // If creating theme, allow Escape to cancel
        if state.creating_theme {
            subs.push(Subscription::keyboard(
                KeyCode::Esc,
                "Cancel create theme",
                Msg::CancelCreateTheme,
            ));
        }

        // If editing color, allow Escape to cancel
        if state.editing_color.is_some() {
            subs.push(Subscription::keyboard(
                KeyCode::Esc,
                "Cancel edit color",
                Msg::CancelEditColor,
            ));
        }

        // If capturing keybind, capture common keys (F-keys, Ctrl+, Alt+)
        if state.capturing_keybind.is_some() {
            use crossterm::event::KeyModifiers;
            use crate::tui::KeyBinding;

            subs.push(Subscription::keyboard(
                KeyCode::Esc,
                "Cancel capture",
                Msg::CancelCaptureKeybind,
            ));
            subs.push(Subscription::keyboard(
                KeyCode::Enter,
                "Save keybind",
                Msg::SaveKeybind,
            ));

            // Subscribe to F-keys (F1-F12)
            for n in 1..=12 {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::F(n), KeyModifiers::empty());
                subs.push(Subscription::keyboard(
                    KeyCode::F(n),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to Ctrl+Letter (A-Z)
            for c in 'a'..='z' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::CONTROL);
                subs.push(Subscription::keyboard(
                    KeyBinding::ctrl(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to Alt+Letter (A-Z)
            for c in 'a'..='z' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::ALT);
                subs.push(Subscription::keyboard(
                    KeyBinding::alt(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to Ctrl+Number (0-9)
            for c in '0'..='9' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::CONTROL);
                subs.push(Subscription::keyboard(
                    KeyBinding::ctrl(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to plain letters (a-z, A-Z)
            for c in 'a'..='z' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::empty());
                subs.push(Subscription::keyboard(
                    KeyCode::Char(c),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }
            for c in 'A'..='Z' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::SHIFT);
                subs.push(Subscription::keyboard(
                    KeyBinding::shift(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to plain numbers (0-9)
            for c in '0'..='9' {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::empty());
                subs.push(Subscription::keyboard(
                    KeyCode::Char(c),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to shifted numbers (symbols: !@#$%^&*())
            let shifted_numbers = ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'];
            for c in shifted_numbers {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::SHIFT);
                subs.push(Subscription::keyboard(
                    KeyBinding::shift(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to common symbols (no modifiers needed)
            let symbols = ['-', '=', '[', ']', '\\', ';', '\'', ',', '.', '/', '`', ' '];
            for c in symbols {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::empty());
                subs.push(Subscription::keyboard(
                    KeyCode::Char(c),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }

            // Subscribe to shifted symbols
            let shifted_symbols = ['_', '+', '{', '}', '|', ':', '"', '<', '>', '?', '~'];
            for c in shifted_symbols {
                let key_event = crossterm::event::KeyEvent::new(KeyCode::Char(c), KeyModifiers::SHIFT);
                subs.push(Subscription::keyboard(
                    KeyBinding::shift(KeyCode::Char(c)),
                    "",
                    Msg::CaptureKey(key_event),
                ));
            }
        }

        subs
    }

    fn title() -> &'static str {
        "Settings"
    }

    fn status(_state: &State) -> Option<Line<'static>> {
        Some(Line::from(vec![
            Span::raw("Configure application options")
        ]))
    }

    fn is_capturing_raw_input(state: &State) -> bool {
        state.capturing_keybind.is_some()
    }
}

impl SettingsApp {
    /// Check if currently capturing a keybind (to skip global keybind handling)
    pub fn is_capturing_keybind(state: &State) -> bool {
        state.capturing_keybind.is_some()
    }

    /// Render the theme editor view (select dropdown of themes with actions)
    fn render_theme_editor(state: &mut State, theme: &crate::tui::Theme) -> (Element<Msg>, String) {
        use_constraints!();

        // Theme selector
        let theme_names = state.theme_names();
        let theme_select = if theme_names.is_empty() {
            Element::panel(
                Element::styled_text(Line::from(vec![
                    Span::styled("No themes available", Style::default().fg(theme.text_tertiary))
                ])).build()
            )
            .title(&format!("Active Theme: {}", &state.active_theme_name))
            .build()
        } else {
            let select_widget = Element::select(
                FocusId::new("theme-select"),
                theme_names,
                &mut state.theme_select_state
            )
            .on_event(Msg::ThemeSelectEvent)
            .build();

            Element::panel(select_widget)
                .title(&format!("Active Theme: {}", &state.active_theme_name))
                .build()
        };

        // Action buttons (no Activate button needed - select auto-activates)
        let create_button = Element::button(
            "theme-create",
            "Create New"
        )
        .on_press(Msg::CreateTheme)
        .build();

        let delete_button = Element::button(
            "theme-delete",
            "Delete"
        )
        .on_press(Msg::DeleteSelectedTheme)
        .build();

        let buttons = row![
            create_button => Length(15),
            Element::text("") => Length(1),
            delete_button => Length(10),
            Element::text("") => Fill(1),
        ];

        // Color preview for selected theme
        let preview_panel = Self::render_theme_preview(state, theme);

        // Combine selector, preview, and buttons
        let content = col![
            theme_select => Length(3),  // Same size as button (borders + content)
            preview_panel => Fill(1),  // 12 color buttons (3 lines each) + panel borders
            buttons => Length(3),  // Buttons with padding
        ];

        let panel = Element::panel(content)
            .title("Themes")
            .build();

        (panel, "Themes".to_string())
    }

    /// Render color swatches preview for the selected theme
    fn render_theme_preview(state: &State, runtime_theme: &crate::tui::Theme) -> Element<Msg> {
        use_constraints!();

        let theme_names = state.theme_names();
        let selected_theme_name = theme_names.get(state.selected_theme_idx);

        if selected_theme_name.is_none() {
            return Element::panel(Element::text("No theme selected"))
                .title("Preview")
                .build();
        }

        let theme_name = selected_theme_name.unwrap();

        // Get the selected theme from state (or fall back to runtime theme if not found)
        let preview_theme = state.themes.get(theme_name).unwrap_or(runtime_theme);

        let colored_box = "";
        let colors = preview_theme.colors();

        // Split colors into three columns (21 colors = 7, 7, 7)
        let per_col = (colors.len() + 2) / 3;
        let col1_colors = &colors[0..per_col.min(colors.len())];
        let col2_colors = &colors[per_col..( per_col * 2).min(colors.len())];
        let col3_colors = &colors[(per_col * 2).min(colors.len())..];

        // Helper to format color name
        let format_display_name = |color_name: &str| -> String {
            color_name.replace('_', " ")
                .split_whitespace()
                .map(|word| {
                    let mut chars = word.chars();
                    match chars.next() {
                        None => String::new(),
                        Some(first) => first.to_uppercase().chain(chars).collect(),
                    }
                })
                .collect::<Vec<_>>()
                .join(" ")
        };

        // Build column 1
        let mut col1_items = Vec::new();
        for (idx, (color_name, color)) in col1_colors.iter().enumerate() {
            // Leak the string to get 'static lifetime for FocusId
            let id = Box::leak(format!("edit-color-{}", idx).into_boxed_str());
            let btn = Element::button(
                FocusId::new(id),
                format!("{}  {}", colored_box, format_display_name(color_name))
            )
            .style(Style::default().fg(*color))
            .on_press(Msg::EditThemeColor(theme_name.clone(), color_name.to_string()))
            .build();
            col1_items.push((Length(3), btn));
        }

        // Build column 2
        let mut col2_items = Vec::new();
        for (idx, (color_name, color)) in col2_colors.iter().enumerate() {
            let id = Box::leak(format!("edit-color-{}", idx + per_col).into_boxed_str());
            let btn = Element::button(
                FocusId::new(id),
                format!("{}  {}", colored_box, format_display_name(color_name))
            )
            .style(Style::default().fg(*color))
            .on_press(Msg::EditThemeColor(theme_name.clone(), color_name.to_string()))
            .build();
            col2_items.push((Length(3), btn));
        }

        // Build column 3
        let mut col3_items = Vec::new();
        for (idx, (color_name, color)) in col3_colors.iter().enumerate() {
            let id = Box::leak(format!("edit-color-{}", idx + per_col * 2).into_boxed_str());
            let btn = Element::button(
                FocusId::new(id),
                format!("{}  {}", colored_box, format_display_name(color_name))
            )
            .style(Style::default().fg(*color))
            .on_press(Msg::EditThemeColor(theme_name.clone(), color_name.to_string()))
            .build();
            col3_items.push((Length(3), btn));
        }

        let col1 = Element::Column { items: col1_items, spacing: 0 };
        let col2 = Element::Column { items: col2_items, spacing: 0 };
        let col3 = Element::Column { items: col3_items, spacing: 0 };

        let preview_row = row![
            col1 => Fill(1),
            col2 => Fill(1),
            col3 => Fill(1),
        ];

        Element::panel(preview_row)
            .title(&format!("Preview: {}", theme_name))
            .build()
    }

    /// Render the keybind editor view
    fn render_keybind_editor(state: &mut State, theme: &crate::tui::Theme) -> (Element<Msg>, String) {
        use_constraints!();
        use crate::config::options::registrations::keybinds;

        // App selector dropdown
        let app_select = if state.keybind_apps.is_empty() {
            Element::styled_text(Line::from(vec![
                Span::styled("No apps available", Style::default().fg(theme.text_tertiary))
            ])).build()
        } else {
            Element::select(
                FocusId::new("keybind-app-select"),
                state.keybind_apps.clone(),
                &mut state.keybind_app_select_state
            )
            .on_event(Msg::KeybindAppSelectEvent)
            .build()
        };

        let app_select_panel = Element::panel(app_select)
            .title("Filter by App")
            .build();

        // Determine which app to filter by
        let filter_app = state.keybind_apps.get(state.selected_keybind_app_idx).map(|s| s.as_str());

        // Build list of keybind items (filtered)
        let mut keybind_items = Vec::new();
        let registry = crate::options_registry();
        for action in &state.keybind_actions {
            // action is in "app.action" format, split it to get app and action name
            let parts: Vec<&str> = action.split('.').collect();
            let (app, action_name) = if parts.len() >= 2 {
                (parts[0], parts[1])
            } else {
                ("", action.as_str())
            };

            // Skip if filtering and app doesn't match
            if let Some(filter) = filter_app {
                if app != filter {
                    continue;
                }
            }

            let display_name = keybinds::get_action_display_name(&registry, app, action_name);
            let current_keybind = state.keybinds.get(action)
                .map(|kb| kb.to_string())
                .unwrap_or_else(|| {
                    // Fall back to default from registry
                    crate::global_runtime_config().get_keybind(action).to_string()
                });

            // Format: "Display Name: [Keybind]"
            let label = format!("{}: [{}]", display_name, current_keybind);

            let item_id = Box::leak(format!("keybind-{}", action).into_boxed_str());
            let item = Element::button(
                FocusId::new(item_id),
                label
            )
            .on_press(Msg::EditKeybind(action.clone()))
            .build();

            keybind_items.push(item);
        }

        let keybind_list = if keybind_items.is_empty() {
            Element::styled_text(Line::from(vec![
                Span::styled("No keybinds available", Style::default().fg(theme.text_tertiary))
            ])).build()
        } else {
            // Split into 3 columns
            let per_col = (keybind_items.len() + 2) / 3;
            let col1_items: Vec<_> = keybind_items.iter().take(per_col).cloned().map(|item| (Length(3), item)).collect();
            let col2_items: Vec<_> = keybind_items.iter().skip(per_col).take(per_col).cloned().map(|item| (Length(3), item)).collect();
            let col3_items: Vec<_> = keybind_items.iter().skip(per_col * 2).cloned().map(|item| (Length(3), item)).collect();

            let col1 = Element::Column { items: col1_items, spacing: 0 };
            let col2 = Element::Column { items: col2_items, spacing: 0 };
            let col3 = Element::Column { items: col3_items, spacing: 0 };

            row![
                col1 => Fill(1),
                col2 => Fill(1),
                col3 => Fill(1),
            ]
        };

        // Reset button
        let reset_button = Element::button(
            "keybind-reset",
            "Reset to Defaults"
        )
        .on_press(Msg::ResetKeybinds)
        .build();

        let content = col![
            app_select_panel => Length(3),
            spacer!() => Length(1),
            keybind_list => Fill(1),
            spacer!() => Length(1),
            reset_button => Length(3),
        ];

        let panel = Element::panel(content)
            .title("Keybinds")
            .build();

        (panel, "Keybinds".to_string())
    }

    /// Render keybind capture modal
    fn render_keybind_capture_modal(state: &State) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        use_constraints!();
        use crate::config::options::registrations::keybinds;

        if let Some(action) = &state.capturing_keybind {
            let registry = crate::options_registry();
            let parts: Vec<&str> = action.split('.').collect();
            let (app, action_name) = if parts.len() >= 2 {
                (parts[0], parts[1])
            } else {
                ("", action.as_str())
            };
            let display_name = keybinds::get_action_display_name(&registry, app, action_name);
            let description = keybinds::get_action_description(&registry, app, action_name);

            let captured_display = if let Some(keybind) = &state.captured_key {
                keybind.to_string()
            } else {
                "Press a key...".to_string()
            };

            let status_style = if state.captured_key.is_some() {
                Style::default().fg(theme.accent_success).bold()
            } else {
                Style::default().fg(theme.text_secondary)
            };

            let content = col![
                Element::styled_text(Line::from(vec![
                    Span::styled(format!("Edit Keybind: {}", display_name), Style::default().fg(theme.accent_primary).bold())
                ])).build() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::styled(description, Style::default().fg(theme.text_tertiary))
                ])).build() => Length(1),
                spacer!() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::styled("Captured: ", Style::default().fg(theme.text_primary)),
                    Span::styled(captured_display, status_style),
                ])).build() => Length(1),
                spacer!() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::styled("Press any key combination to capture it.", Style::default().fg(theme.text_secondary))
                ])).build() => Length(1),
                spacer!() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::styled("Enter", Style::default().fg(theme.accent_success).bold()),
                    Span::raw(" Save  "),
                    Span::styled("Esc", Style::default().fg(theme.accent_error).bold()),
                    Span::raw(" Cancel"),
                ])).build() => Length(1),
            ];

            Element::panel(
                Element::container(content)
                    .padding(2)
                    .build()
            )
            .title("Capture Keybind")
            .width(60)
            .height(16)
            .build()
        } else {
            Element::text("Error: No keybind being captured")
        }
    }

    fn render_color_picker_modal(state: &mut State) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        use_constraints!();

        if let Some(editing) = &state.editing_color {
            let picker = Element::color_picker(
                FocusId::new("color-picker"),
                &state.color_picker_state
            )
            .on_event(Msg::ColorPickerEvent)
            .build();

            let title = format!("Edit Color: {} - {}", editing.theme_name, editing.color_name);

            // Show current color preview
            let colored_box = "";
            let hex_value = format!("#{}", state.color_picker_state.hex());
            let preview_line = Line::from(vec![
                Span::raw("Current: "),
                Span::styled(colored_box, Style::default().fg(state.color_picker_state.color())),
                Span::raw("  "),
                Span::styled(hex_value, Style::default().fg(theme.text_secondary)),
            ]);

            let content = col![
                Element::styled_text(preview_line).build() => Length(1),
                Element::text("") => Length(1),
                picker => Length(9),
                Element::text("") => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::styled("Controls: ", Style::default().fg(theme.text_primary).bold()),
                ])).build() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::raw("  "),
                    Span::styled("/", Style::default().fg(theme.accent_primary).bold()),
                    Span::raw(" Adjust value  "),
                    Span::styled("Tab", Style::default().fg(theme.accent_primary).bold()),
                    Span::raw(" Next channel  "),
                    Span::styled("M", Style::default().fg(theme.accent_primary).bold()),
                    Span::raw(" Toggle HSL/RGB"),
                ])).build() => Length(1),
                Element::styled_text(Line::from(vec![
                    Span::raw("  "),
                    Span::styled("Enter", Style::default().fg(theme.accent_success).bold()),
                    Span::raw(" Save  "),
                    Span::styled("Esc", Style::default().fg(theme.accent_error).bold()),
                    Span::raw(" Cancel"),
                ])).build() => Length(1),
            ];

            Element::panel(content)
                .title(&title)
                .build()
        } else {
            Element::text("Error: No color being edited")
        }
    }

    fn render_create_theme_modal(state: &mut State) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        use_constraints!();

        let input_widget = Element::text_input(
            FocusId::new("create-theme-input"),
            &state.create_theme_input,
            &state.create_theme_input_state
        )
        .on_event(Msg::CreateThemeInput)
        .build();

        let input_panel = Element::panel(input_widget)
            .title("Theme Name")
            .build();

        let hint_text = format!(
            "Enter a name for the new theme. It will be copied from '{}'.",
            state.active_theme_name
        );

        let content = col![
            input_panel => Length(5),
            Element::text("") => Length(1),
            Element::styled_text(Line::from(vec![
                Span::styled(hint_text, Style::default().fg(theme.text_tertiary))
            ])).build() => Length(1),
            Element::text("") => Length(1),
            Element::styled_text(Line::from(vec![
                Span::raw("Press "),
                Span::styled("Enter", Style::default().fg(theme.accent_primary).bold()),
                Span::raw(" to create, "),
                Span::styled("Esc", Style::default().fg(theme.accent_primary).bold()),
                Span::raw(" to cancel"),
            ])).build() => Length(1),
        ];

        Element::panel(content)
            .title("Create New Theme")
            .build()
    }

    fn render_edit_modal(
        state: &mut State,
        opt: &OptionDefinition,
    ) -> Element<Msg> {
        let theme = &crate::global_runtime_config().theme;
        use_constraints!();

        // Build the edit widget with proper panel wrapping (matching other modals)
        let (value_panel, hint) = if let Some(EditingState::TextInput { key, input }) = &state.editing {
            if key == &opt.key {
                let input_widget = Element::text_input(
                    FocusId::new("edit-input"),
                    input.as_str(),
                    &state.edit_input_state
                )
                .on_event(Msg::EditInputEvent)
                .build();

                (
                    Element::panel(input_widget).title("Value").build(),
                    "Press Enter to save, Esc to cancel"
                )
            } else {
                return Element::text("Invalid edit state"); // Should not happen
            }
        } else if let Some(EditingState::Select { key, options }) = &state.editing {
            if key == &opt.key {
                let select_widget = Element::select(
                    FocusId::new("edit-select"),
                    options.clone(),
                    &mut state.edit_select_state
                )
                .on_event(Msg::EditSelectEvent)
                .build();

                let hint_text = if state.edit_select_state.is_open() {
                    "Up/Down to navigate, Enter to select, Esc to close"
                } else {
                    "Press Enter to open dropdown, Esc to cancel"
                };

                (
                    Element::panel(select_widget).title("Value").build(),
                    hint_text
                )
            } else {
                return Element::text("Invalid edit state"); // Should not happen
            }
        } else {
            return Element::text("No edit state"); // Should not happen
        };

        // Build modal content following the same pattern as other modals
        // Height calculation: 1 + 1 + 1 + 3 + 1 + 1 + 10 = 18 lines
        // + padding(2) = 4 lines (top 2, bottom 2)
        // + outer panel borders = 2 lines
        // Total = 24 lines minimum
        let modal_body = col![
            // Option name and description
            Element::styled_text(Line::from(vec![
                Span::styled(opt.display_name.clone(), Style::default().fg(theme.accent_primary).bold())
            ])).build() => Length(1),
            Element::styled_text(Line::from(vec![
                Span::styled(opt.description.clone(), Style::default().fg(theme.text_tertiary))
            ])).build() => Length(1),
            spacer!() => Length(1),
            // Value panel (nested panel with input/select inside)
            value_panel => Length(3),
            spacer!() => Length(1),
            // Hint
            Element::styled_text(Line::from(vec![
                Span::styled(hint.to_string(), Style::default().fg(theme.text_tertiary))
            ])).build() => Length(1),
            // Extra space for dropdown overlay
            spacer!() => Length(12),
        ];

        // Wrap in outer panel with title, width, and height
        Element::panel(
            Element::container(modal_body)
                .padding(2)
                .build()
        )
        .title("Edit Option")
        .width(60)
        .height(26)
        .build()
    }
}

pub struct SettingsApp;
