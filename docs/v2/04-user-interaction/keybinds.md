# Keybinds (First-Class)

**Prerequisites:** [App & Context API](../01-fundamentals/app-and-context.md), [Options System](../03-state-management/options.md)

## Overview

The V2 keybind system uses the **Options system** for storage and customization:

- **Three categories:** Navigation (global nav keys), Global (runtime actions), App (app-specific)
- **Alias support:** Multiple keys per action (`.alias1`, `.alias2`, etc.) - non-destructive
- **Vim mode:** Built-in preset system for vim navigation
- **SQLite storage:** All keybinds stored in Options database
- **Conflict detection:** Warns about overlapping bindings
- **Auto-registration:** Proc macro extracts keybinds and registers to Options

## App Keybind Definition

Apps define keybinds in the `keybinds()` method:

```rust
#[derive(Keybinds)]  // Proc macro auto-registers to Options
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .bind("save", "Save changes", KeyBinding::ctrl(KeyCode::Char('s')), Self::handle_save)
            .bind("quit", "Quit app", KeyBinding::new(KeyCode::Char('q')), Self::handle_quit)
            .bind("refresh", "Refresh data", KeyBinding::new(KeyCode::Char('r')), Self::handle_refresh)
    }
}
```

**Components:**
- **Action ID** - Unique identifier ("save", "quit") - scoped to app automatically
- **Description** - Shown in help menu and settings UI
- **Default KeyBinding** - Default binding (can be customized by user)
- **Handler** - Method reference (async supported)

## Automatic Options Registration

The `#[derive(Keybinds)]` macro generates an `register_options()` method:

```rust
// Generated by macro
impl MyApp {
    pub fn register_options(registry: &OptionsRegistry) -> Result<()> {
        registry.register(
            OptionDefBuilder::new("keybind", "my_app.save")
                .display_name("Save changes")
                .keybind_type(KeyBinding::ctrl(KeyCode::Char('s')))
                .build()?
        )?;
        registry.register(
            OptionDefBuilder::new("keybind", "my_app.quit")
                .display_name("Quit app")
                .keybind_type(KeyBinding::new(KeyCode::Char('q')))
                .build()?
        )?;
        registry.register(
            OptionDefBuilder::new("keybind", "my_app.refresh")
                .display_name("Refresh data")
                .keybind_type(KeyBinding::new(KeyCode::Char('r')))
                .build()?
        )?;
        Ok(())
    }
}
```

**Runtime calls this at app registration:**
```rust
impl Runtime {
    pub fn register_app<A: App>(&mut self) -> Result<()> {
        // Auto-register keybinds to Options system
        A::register_options(&self.options_registry)?;

        // Store keybind map for runtime dispatch
        self.app_keybinds.insert(A::app_id(), A::keybinds());

        Ok(())
    }
}
```

## User Customization via Options

**Primary binding stored in SQLite:**
```sql
INSERT INTO options VALUES ('keybind.my_app.save', 'Ctrl+s');
```

**User can add aliases (non-destructive):**
```rust
// Via settings UI or programmatically
options.set("keybind.my_app.save.alias1", "s").await?;
options.set("keybind.my_app.save.alias2", "Ctrl+Shift+s").await?;
```

**All bindings trigger the same handler:**
- `Ctrl+s` (primary)
- `s` (alias1)
- `Ctrl+Shift+s` (alias2)

## Navigation Bindings (Global)

**Navigation bindings are framework-level** - registered once at startup, not per-app:

```rust
// In framework initialization (not app code)
pub fn register_navigation_keybinds(registry: &OptionsRegistry) -> Result<()> {
    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.up")
            .display_name("Navigate Up")
            .description("Move selection/cursor up in focused component")
            .keybind_type(KeyBinding::new(KeyCode::Up))
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.down")
            .display_name("Navigate Down")
            .keybind_type(KeyBinding::new(KeyCode::Down))
            .build()?
    )?;

    // ... more navigation bindings (left, right, activate, cancel, etc.)

    Ok(())
}
```

**Navigation keys are abstracted as NavAction enum:**

```rust
pub enum NavAction {
    Up, Down, Left, Right,
    PageUp, PageDown,
    Home, End,
    Activate,  // Enter/Space
    Cancel,    // Esc
    Next,      // Tab
    Previous,  // Shift+Tab
}
```

**Widgets handle NavActions internally** - apps never see navigation keys:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![Layer::fill(panel("Queue", |ui| {
        // List automatically handles NavAction::Up, Down, Activate, etc.
        ui.list(&mut self.list_state, &self.items);

        // Tree handles Up, Down, Left (collapse), Right (expand)
        ui.tree(&mut self.tree_state, &self.nodes);

        // Text input handles typing + NavAction::Activate (submit)
        ui.text_input(&mut self.input);
    }))]
}
```

**Framework routing priority:**
1. **Navigation bindings** → Send NavAction to focused widget
2. **Global keybinds** → Runtime actions (help, launcher, quit)
3. **App keybinds** → App-specific handlers
4. **Unbound** → Ignore

## Vim Mode & Presets

**Users can enable Vim navigation** (non-destructive):

```rust
// Settings UI button applies this preset
pub async fn apply_vim_preset(options: &Options) -> Result<()> {
    options.set("keybind.global.nav.up.alias1", "k").await?;
    options.set("keybind.global.nav.down.alias1", "j").await?;
    options.set("keybind.global.nav.left.alias1", "h").await?;
    options.set("keybind.global.nav.right.alias1", "l").await?;
    options.set("keybind.global.nav.page_up.alias1", "Ctrl+u").await?;
    options.set("keybind.global.nav.page_down.alias1", "Ctrl+d").await?;
    options.set("keybind.global.nav.home.alias1", "g").await?;
    options.set("keybind.global.nav.end.alias1", "G").await?;
    Ok(())
}
```

**After applying preset:**
- ↑/↓/←/→ still work (primary bindings unchanged)
- k/j/h/l also work (added as aliases)
- User can add custom aliases too

## Conflict Detection

**Settings UI warns about key conflicts:**

```rust
pub fn find_conflicts(key: KeyBinding, registry: &OptionsRegistry) -> Vec<String> {
    let mut conflicts = vec![];

    for option_def in registry.list_namespace("keybind") {
        if let Ok(bound_key) = option_def.default.as_keybind() {
            if bound_key == key {
                conflicts.push(option_def.key.clone());
            }
        }
    }

    conflicts
}
```

**Example conflict warning:**
```
⚠️ Warning: Key 'k' is bound to multiple actions:
  - keybind.global.nav.up.alias1 (Navigate Up)
  - keybind.my_app.create (Create Item)

Navigation binding takes precedence when component is focused.
App binding triggers when no component is focused.
```

## Button Integration

Buttons and keybinds can call the same handler:

```rust
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .bind("clear", "Clear all items", KeyBinding::new(KeyCode::Char('c')), Self::handle_clear)
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        vec![Layer::fill(panel("Queue", |ui| {
            ui.list(&mut self.list_state, &self.items);

            // Button calls same handler as keybind
            ui.button("Clear All").on_click(Self::handle_clear);
        }))]
    }

    async fn handle_clear(&mut self, ctx: &mut Context) {
        self.items.clear();
    }
}
```

**Framework can show keybind in UI:**
```
[Clear All (c)]  ← Button shows associated keybind automatically
```

**See Also:**
- [Navigation](navigation.md) - Tab/Shift-Tab focus navigation
- [Focus System](focus.md) - Focus management details
- [Component Patterns](component-patterns.md) - Handler patterns
- [Help System](../06-system-features/help-system.md) - Auto-generated help from keybinds
- [Options System](../03-state-management/options.md) - Options architecture

---

## Implementation Details

### Three Keybind Categories

**1. Navigation Bindings** (`keybind.global.nav.*`)
   - Semantic navigation actions (up, down, activate, cancel, etc.)
   - Sent directly to focused components as `NavAction` enum
   - Components handle internally (no app code needed)
   - User can add vim-style or custom aliases

**2. Global Bindings** (`keybind.global.*`)
   - Runtime-level actions (help menu, app launcher, quit, etc.)
   - Checked after navigation but before app bindings

**3. App Bindings** (`keybind.{app_id}.*`)
   - App-specific actions
   - Lowest priority in key handling
   - Auto-registered via `#[derive(Keybinds)]` macro

### Runtime Key Dispatch

**Priority order when key is pressed:**

```rust
impl Runtime {
    fn handle_key(&mut self, key_event: KeyEvent) {
        // 1. Check if key is bound to a navigation action
        if let Some((nav_key, nav_action)) = self.lookup_navigation(key_event) {
            if let Some(focused) = self.focused_component() {
                if focused.handle_nav(nav_action) {
                    return;  // Component consumed the navigation action
                }
            }
        }

        // 2. Check global keybinds
        if let Some(global_action) = self.lookup_global_keybind(key_event) {
            self.handle_global_action(global_action);
            return;
        }

        // 3. Check app keybinds
        if let Some(app_action) = self.active_app.lookup_keybind(key_event) {
            app_action.call(&mut self.active_app);
            return;
        }

        // 4. Ignored - key not bound to anything
    }

    /// Lookup which navigation action this key triggers (checks primary + all aliases)
    fn lookup_navigation(&self, key: KeyEvent) -> Option<(&str, NavAction)> {
        for nav_key in &["up", "down", "left", "right", "activate", "cancel",
                         "page_up", "page_down", "home", "end", "next", "previous"] {
            let base_key = format!("global.nav.{}", nav_key);

            // Check primary binding
            let primary_option_key = format!("keybind.{}", base_key);
            if let Ok(bound_str) = self.config.options.get_string(&primary_option_key) {
                if let Ok(bound_key) = KeyBinding::from_str(&bound_str) {
                    if bound_key.matches(&key) {
                        if let Some(action) = NavAction::from_option_key(&base_key) {
                            return Some((nav_key, action));
                        }
                    }
                }
            }

            // Check aliases (alias1, alias2, ..., alias10)
            for i in 1..=10 {
                let alias_option_key = format!("keybind.{}.alias{}", base_key, i);
                if let Ok(bound_str) = self.config.options.get_string(&alias_option_key) {
                    if let Ok(bound_key) = KeyBinding::from_str(&bound_str) {
                        if bound_key.matches(&key) {
                            if let Some(action) = NavAction::from_option_key(&base_key) {
                                return Some((nav_key, action));
                            }
                        }
                    }
                }
            }
        }
        None
    }
}
```

### Component Navigation Handling

**Components handle NavActions internally** - apps never see navigation keys:

```rust
// Internal to framework - apps don't touch this
impl ListComponent {
    fn handle_nav(&mut self, action: NavAction) -> bool {
        match action {
            NavAction::Up => {
                self.state.navigate_up();
                true  // Consumed
            }
            NavAction::Down => {
                self.state.navigate_down();
                true  // Consumed
            }
            NavAction::PageUp => {
                self.state.navigate_page_up();
                true
            }
            NavAction::Activate => {
                // Emit semantic event to app
                self.emit(ListEvent::Activated(self.state.selected()));
                true
            }
            _ => false  // Doesn't handle this action
        }
    }
}
```

### Proc Macro Code Generation

**The `#[derive(Keybinds)]` macro parses `keybinds()` method** and generates registration code:

```rust
// Macro input
#[derive(Keybinds)]
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .bind("save", "Save changes", KeyBinding::ctrl(KeyCode::Char('s')), Self::handle_save)
            .bind("quit", "Quit app", KeyBinding::new(KeyCode::Char('q')), Self::handle_quit)
    }
}

// Macro output - extracts all .bind() calls
impl MyApp {
    pub fn register_options(registry: &OptionsRegistry) -> Result<()> {
        registry.register(
            OptionDefBuilder::new("keybind", "my_app.save")
                .display_name("Save changes")
                .keybind_type(KeyBinding::ctrl(KeyCode::Char('s')))
                .build()?
        )?;
        registry.register(
            OptionDefBuilder::new("keybind", "my_app.quit")
                .display_name("Quit app")
                .keybind_type(KeyBinding::new(KeyCode::Char('q')))
                .build()?
        )?;
        Ok(())
    }
}
```

**Macro parses AST** to find all `map.bind()` calls across ALL code paths (including conditional branches).

**Alternative:** Use `inventory` crate for distributed collection instead of generated method.

### Settings UI Reference

**Per-action keybind editor:**
```
╭─ Navigate Up ─────────────────────────────────╮
│ Primary:  ↑                      [Edit]       │
│ Alias 1:  k                      [Remove]     │
│ Alias 2:  w                      [Remove]     │
│                                  [Add Alias]  │
├───────────────────────────────────────────────┤
│ Description: Move selection/cursor up in      │
│              focused component                │
╰───────────────────────────────────────────────╯

[Apply Vim Preset]  [Remove Vim Preset]  [Reset to Defaults]
```

**Keybind listing grouped by category:**
```
╭─ Global Navigation ───────────────────────────╮
│ Navigate Up       ↑, k, w                     │
│ Navigate Down     ↓, j                        │
│ Activate          Enter                       │
│ Cancel            Esc                         │
├─ Global Actions ──────────────────────────────┤
│ Help Menu         F1                          │
│ App Launcher      Ctrl+A                      │
│ Quit              Ctrl+Q                      │
├─ App: MyApp ──────────────────────────────────┤
│ Save              Ctrl+s, s                   │
│ Quit              q                           │
╰───────────────────────────────────────────────╯
```

---

**Next:** Learn about [Focus System](focus.md) for focus management.
