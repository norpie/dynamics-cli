# TUI Framework V2 - Design Brainstorm

**Status**: Design phase - Not ready for implementation

## Core Philosophy

### Immediate Mode + Structured Concurrency

- Apps get `&mut self` during render - direct mutation, no message passing
- Async is first-class via Resource/tasks
- Event-driven rendering only (no FPS loop)
- Zero boilerplate for common patterns

### What We're Fixing from V1

1. **Message Explosion** - Every interaction needs a Msg enum variant
2. **Command Ceremony** - Side effects require wrapping in Command::Perform
3. **Navigation/Focus Boilerplate** - Manual event routing, on_render callbacks
4. **Multi-View Hacks** - Separate apps when they should share state
5. **Hardcoded Layers** - GlobalUI, AppModal, etc. baked into framework
6. **Viewport Dimension Hacks** - "20" fallback + on_render callback for real size
7. **Keybind Hell** - Hardcoded keys, no user configuration

---

## Architecture

### App Trait

```rust
trait App: 'static {
    // Called once on creation
    fn new(ctx: &AppContext) -> Self;

    // Called on every event or invalidation - returns UI + layers
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer>;

    // Optional: Define app-specific keybinds
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
    }

    // Optional lifecycle
    fn on_background(&mut self) {}
    fn on_foreground(&mut self) {}
}
```

**No separate `view()` method** - `update()` handles events AND returns UI.

### Context API

```rust
struct Context {
    // View routing (multi-view apps)
    router: Router,

    // Task spawning with auto-polling
    tasks: TaskManager,

    // Pub/sub with auto-routing
    pubsub: PubSub,

    // UI builder (immediate mode)
    ui: UiBuilder,
}
```

### Example: Simple App

```rust
struct QueueApp {
    list_state: ListState,
    items: Vec<QueueItem>,
}

impl App for QueueApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("clear", "Clear queue", default_key!("Ctrl+K"), Self::handle_clear)
            .action("execute", "Execute", default_key!("Enter"), Self::handle_execute)
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        vec![
            Layer::fill(panel("Queue", |ui| {
                ui.text(format!("{} items", self.items.len()));

                // List auto-handles arrow keys - no boilerplate!
                ui.list(&mut self.list_state, &self.items, |item, ui| {
                    ui.text(&item.name);
                });

                // Button calls handler when clicked
                ui.button("Clear").on_click(Self::handle_clear);
            }))
        ]
    }

    // Handlers as separate methods (can be async!)
    async fn handle_clear(&mut self, ctx: &mut Context) {
        self.items.clear();
    }

    async fn handle_execute(&mut self, ctx: &mut Context) {
        if let Some(idx) = self.list_state.selected() {
            self.execute_item(idx).await;
        }
    }
}
```

---

## Multi-View Apps

**Problem**: Deadlines has FileSelect → Mapping → Inspection as 3 separate apps when it should be 1 app with 3 views sharing state.

**Solution**: Router

```rust
struct DeadlinesApp {
    // Shared state across all views
    file: Option<PathBuf>,
    mappings: HashMap<String, String>,
    parsed_data: Resource<Vec<Deadline>>,

    // View-specific state
    file_browser: FileBrowserState,
    mapping_list: ListState,
    inspection_tree: TreeState,
}

impl App for DeadlinesApp {
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // Route to current view
        let ui = match ctx.router.current() {
            VIEW_FILE_SELECT => self.view_file_select(ctx),
            VIEW_MAPPING => self.view_mapping(ctx),
            VIEW_INSPECTION => self.view_inspection(ctx),
            _ => empty(),
        };

        vec![Layer::fill(ui)]
    }

    fn view_file_select(&mut self, ctx: &mut Context) -> Element {
        panel("Select File", |ui| {
            ui.file_browser(&mut self.file_browser);

            // Events returned inline - no closures!
            if let Some(Event::FileSelected(path)) = ui.events().file_browser() {
                self.file = Some(path.clone());

                // Start loading
                self.parsed_data.load(ctx, parse_excel(path));

                // Navigate to next view
                ctx.router.navigate(VIEW_MAPPING);
            }
        })
    }

    fn view_mapping(&mut self, ctx: &mut Context) -> Element {
        panel("Map Columns", |ui| {
            self.parsed_data.render(ui, |data, ui| {
                ui.list(&mut self.mapping_list, &self.mappings);

                if ui.button("Next").clicked() {
                    ctx.router.navigate(VIEW_INSPECTION);
                }
            });
        })
    }

    fn view_inspection(&mut self, ctx: &mut Context) -> Element {
        // Third view - same app, shared state!
        panel("Inspect", |ui| {
            self.parsed_data.render(ui, |data, ui| {
                ui.tree(&mut self.inspection_tree, data);
            });
        })
    }
}
```

---

## Pub/Sub (Auto-Managed)

**No manual polling** - framework calls handler methods automatically.

```rust
impl App for OperationQueue {
    fn new(ctx: &AppContext) -> Self {
        // Subscribe with handler method
        ctx.subscribe("operations:add", Self::on_operations_received);

        Self { queue: Vec::new() }
    }

    // Called automatically when message arrives (even in background!)
    fn on_operations_received(&mut self, msg: Message) {
        let ops: Vec<Operation> = msg.parse();
        self.queue.extend(ops);
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // No manual polling needed!
        vec![
            Layer::fill(panel("Queue", |ui| {
                ui.list(&mut self.queue_state, &self.queue);
            }))
        ]
    }
}

// Publishing from another app
fn some_handler(&mut self, ctx: &mut Context) {
    ctx.pubsub.publish("operations:add", &self.data);
}
```

**Framework handles all Arc/Mutex/RwLock internally.**

---

## Resource Pattern (Auto-Managed Async)

```rust
struct MyApp {
    data: Resource<Data>,
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Data", |ui| {
            if ui.button("Load").clicked() {
                // Framework handles spawning, polling, invalidation
                self.data.load(ctx, async {
                    fetch_data().await
                });
            }

            // Resource has built-in render method
            self.data.render(ui,
                || spinner(),           // Loading
                |data| text(data),      // Success
                |err| error(err),       // Failure
            );
        }))
    ]
}
```

`ctx.spawn_into()` handles Arc/Mutex, updates Resource when complete, auto-invalidates UI.

---

## Keybinds (First-Class)

### Declarative Definition

```rust
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("save", "Save changes", default_key!("Ctrl+S"), Self::handle_save)
            .action("quit", "Quit app", default_key!("q"), Self::handle_quit)
            .action("refresh", "Refresh data", default_key!("r"), Self::handle_refresh)
    }
}
```

### User Configuration

```toml
# ~/.config/dynamics/keybinds.toml
[global]
app_launcher = "Ctrl+Space"
help = "F1"
quit = "Ctrl+Q"

[app.EntityComparison]
save = "Ctrl+S"
refresh = "F5"
quit = "Escape"  # Override global for this app
```

### Automatic Widget Navigation

**Widgets handle their own keys automatically - zero boilerplate!**

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Queue", |ui| {
            // List gets arrow keys automatically!
            ui.list(&mut self.list_state, &self.items);

            // Tree gets arrows + Space automatically!
            ui.tree(&mut self.tree_state, &self.nodes);

            // Text input gets typing automatically!
            ui.text_input(&mut self.input);
        }))
    ]
}
```

**Framework routing (hidden from user):**

1. Check focused widget - does it want this key?
2. Not consumed? Check global keybinds (app_launcher, help, etc.)
3. Still not consumed? Check app keybinds
4. Not bound? Ignore

### Button Keybind Integration

```rust
// Button and keybind independently call same handler
ui.button("Clear All").on_click(Self::handle_clear);

// Framework can optionally show "Clear All (Ctrl+K)" by matching handler signatures
```

---

## Layer System (Simple Stack)

**No enum, no hardcoded types - just a stack with metadata.**

```rust
struct Layer {
    element: Element,
    area: LayerArea,
    dim_below: bool,
    blocks_input: bool,
}

enum LayerArea {
    Fill,                      // Use all available space
    Centered(u16, u16),        // Width, height
    Rect(Rect),                // Explicit position
    Anchor(Anchor, u16, u16),  // TopLeft, BottomRight, etc.
    DockTop(u16),              // Reserve N lines at top
    DockBottom(u16),
    DockLeft(u16),
    DockRight(u16),
}
```

### Multi-Layer Example

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        // Base UI
        Layer::fill(self.main_ui()),
    ];

    // Confirmation modal (if showing)
    if self.show_confirm {
        layers.push(
            Layer::centered(50, 15, panel("Confirm?", |ui| {
                ui.text("Are you sure?");
                ui.button("Yes").on_click(Self::handle_confirm);
                ui.button("No").on_click(Self::handle_cancel);
            }))
            .dim_below(true)
            .blocks_input(true)
        );
    }

    // Tooltip (always on top, doesn't block input)
    if let Some(tooltip) = &self.tooltip {
        layers.push(
            Layer::at(self.mouse_pos, text(tooltip))
        );
    }

    layers
}
```

### Global UI = Just Another Layer

Instead of hardcoded `GlobalUI`, runtime provides header/footer via system layers:

```rust
// Runtime automatically prepends/appends system layers
fn render(&mut self) {
    let mut all_layers = vec![];

    // System header (unless app opts out)
    if !app.layout_mode().is_fullscreen() {
        all_layers.push(
            Layer::dock_top(3, self.render_header())
        );
    }

    // Get app's layers
    all_layers.extend(self.active_app.update());

    // System help modal (if F1 pressed)
    if self.showing_help {
        all_layers.push(
            Layer::centered(80, 30, self.render_help())
                .dim_below(true)
                .blocks_input(true)
        );
    }

    self.renderer.render(&all_layers);
}
```

Apps can opt out:

```rust
impl App for FullscreenVideoPlayer {
    fn layout_mode() -> LayoutMode {
        LayoutMode::Fullscreen  // No header/footer
    }
}
```

---

## Widget Dimensions (No More Hacks!)

**V1 Problem**: Scrollable widgets need viewport dimensions, but we don't know until render. Solution was "20" fallback + `on_render` callback - 1-frame delay hack!

**V2 Solution**: Immediate mode - widgets get dimensions during render:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Records", |ui| {
            // ui.list() happens during render, already knows its size!
            ui.list(&mut self.list_state, &self.records);

            // No viewport_height param needed
            // No on_render callback
            // No hardcoded "20" fallback
        }))
    ]
}
```

---

## Focus System

### Automatic Focus Order (Zero Boilerplate)

Focus order follows **render order** - no explicit registration needed:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name);     // Focus index 0
            ui.text_input(&mut self.email);    // Focus index 1
            ui.button("Cancel");               // Focus index 2
            ui.button("Submit");               // Focus index 3
        }))
    ]
}
```

**Tab/Shift-Tab** cycles through indices: 0 → 1 → 2 → 3 → 0.

### Layer-Scoped Focus (Auto-Restoration)

Each layer maintains independent focus state:

```rust
Layer 0 (Base App):     focused_index = Some(2)  // "Submit" button
Layer 1 (Modal):        focused_index = Some(0)  // "Yes" button (receiving input)
```

When modal closes, Layer 0's focus is **automatically restored to index 2** - no manual tracking!

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(self.main_form(ctx))  // Has focus on "Submit"
    ];

    if self.show_confirm {
        layers.push(
            Layer::centered(40, 10, panel("Confirm?", |ui| {
                ui.button("Yes");  // Gets focus when modal opens
                ui.button("No");
            }))
        );
    }

    layers  // When confirm closes, "Submit" auto-focused again
}
```

### Programmatic Focus

Two approaches for different use cases:

#### 1. Declarative (Common Case)

Focus based on app state - evaluated during widget construction:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name)
                .auto_focus(self.name_invalid);  // Focus if validation failed

            ui.text_input(&mut self.email);

            ui.button("Submit")
                .auto_focus(self.just_loaded);  // Focus on first render
        }))
    ]
}
```

#### 2. Imperative (Rare Cases)

Programmatic focus by ID - applied after UI construction completes (same render cycle):

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Select File", |ui| {
            ui.file_browser(&mut self.browser);

            // User just selected file
            if let Some(Event::FileSelected(path)) = ui.events().file_browser() {
                self.handle_file_selected(path);
                ctx.focus.request("continue-button");  // Focus continue button
            }

            ui.button("Continue").id("continue-button");
        }))
    ]
}
```

**Focus requests are applied immediately** (in the same render cycle, after UI construction).

**Optional IDs** - only needed for programmatic focus. Most widgets don't need them.

### User Navigation Takes Precedence

**Problem**: What if auto-focus competes with user navigation?

```rust
// Frame 1: File selected, button auto-focused
ui.button("Continue").auto_focus(file_selected);  // ✓ Focused

// Frame 2: User presses Shift+Tab to go back
// auto_focus(file_selected) is STILL true!
// Who wins? 🤔
```

**Solution**: User navigation events suppress auto-focus hints:

```rust
impl Runtime {
    fn handle_event_and_render(&mut self, event: Event) {
        // 1. Handle user navigation FIRST (before app update)
        let user_navigated = match event {
            Event::Key(KeyCode::Tab) => { self.focus.next(); true }
            Event::Key(KeyCode::BackTab) => { self.focus.prev(); true }
            Event::Mouse(click) => { self.focus.set_from_click(click); true }
            _ => false
        };

        // 2. Let app update and build UI
        let ctx = Context { user_navigated, ... };
        let layers = self.app.update(ctx);

        // 3. Apply auto-focus hints ONLY if user didn't navigate
        if !user_navigated {
            self.apply_auto_focus_hints();
        }

        // 4. Render
        self.render(layers);
    }
}
```

**Behavior**:
- File selected → button auto-focused ✓
- User presses Shift+Tab → focus moves to previous element ✓
- User can freely navigate, auto-focus doesn't fight back ✓

### Progressive Unfocus (Esc Behavior)

```rust
impl Runtime {
    fn handle_escape(&mut self) {
        // 1. If something focused on top layer, blur it
        if self.focus.top_layer().has_focus() {
            self.focus.top_layer_mut().blur();
            return;
        }

        // 2. If multiple layers, close top layer (modal)
        if self.layers.len() > 1 {
            self.layers.pop();
            // Focus automatically restored to layer below!
            return;
        }

        // 3. Quit app
        self.quit();
    }
}
```

**Behavior**: Esc → blur current → close layer → quit app

### Focus Modes (User Configurable)

```rust
enum FocusMode {
    Click,              // Focus only on click (default)
    Hover,              // Focus follows mouse
    HoverWhenUnfocused, // Hover only when nothing focused
}
```

**User config**:
```toml
# ~/.config/dynamics/config.toml
[ui]
focus_mode = "HoverWhenUnfocused"
```

**Runtime handles mouse moves based on mode**:

```rust
impl Runtime {
    fn handle_mouse_move(&mut self, x: u16, y: u16) {
        let element = self.hit_test(x, y);

        match self.config.focus_mode {
            FocusMode::Hover => {
                if let Some(idx) = element.focus_index {
                    self.focus.set_index(idx);
                }
            }
            FocusMode::HoverWhenUnfocused => {
                if !self.focus.has_focus() {
                    if let Some(idx) = element.focus_index {
                        self.focus.set_index(idx);
                    }
                }
            }
            FocusMode::Click => { /* no-op */ }
        }
    }
}
```

### Focus Context API

```rust
impl Context {
    pub fn focus(&mut self) -> &mut FocusManager;
}

struct FocusManager {
    current_layer: usize,
    layers: Vec<LayerFocusState>,
}

impl FocusManager {
    // Request focus by ID (applied after UI construction)
    pub fn request(&mut self, id: &str);

    // Request focus on first focusable (for view navigation)
    pub fn request_first(&mut self);

    // Request focus on last focusable
    pub fn request_last(&mut self);

    // Clear focus (blur current element)
    pub fn blur(&mut self);

    // Check if anything is focused
    pub fn has_focus(&self) -> bool;
}
```

### Implementation Details

Each layer maintains its own focus list:

```rust
struct LayerFocusState {
    focused_index: Option<usize>,
    focusables: Vec<FocusableInfo>,
    id_to_index: HashMap<String, usize>,
}

struct FocusableInfo {
    index: usize,
    id: Option<String>,        // Optional, only if widget has .id("foo")
    element_type: ElementType, // For debugging/help text
}
```

Widgets auto-register as they render:

```rust
impl UiBuilder {
    pub fn button(&mut self, label: &str) -> ButtonBuilder {
        let focus_idx = self.current_layer_focusables.len();
        let is_focused = self.current_focused == Some(focus_idx);

        self.current_layer_focusables.push(FocusableInfo {
            index: focus_idx,
            id: None,
            element_type: ElementType::Button,
        });

        ButtonBuilder { focus_idx, is_focused, ... }
    }
}
```

**Key insight**: Focus list IS the render list - precomputed automatically during UI construction.

---

## Mouse Support

### Hit Testing (1-Frame Delay)

**Problem**: During `update()`, we're building UI but don't know element positions yet (layout happens after).

**Solution**: Use **previous frame's rectangles** for hover detection:

```rust
struct MouseState {
    position: (u16, u16),
    left_button: ButtonState,
    right_button: ButtonState,
    middle_button: ButtonState,
    scroll_delta: i16,
    element_rects: HashMap<String, Rect>,  // From PREVIOUS frame
}

impl MouseState {
    fn is_over(&self, id: &str) -> bool {
        self.element_rects.get(id)
            .map(|rect| rect.contains(self.position))
            .unwrap_or(false)
    }
}
```

**Runtime flow**:
1. Mouse moves to (50, 10)
2. App calls `update()` → builds UI
3. Widgets check `ctx.mouse.is_over("my-button")` using last frame's rect
4. Runtime renders and computes new positions
5. Runtime updates `element_rects` for next frame

**1-frame delay (16ms @ 60fps)** - imperceptible to users!

### Inline Event Handling

Widgets return events inline - no message passing:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Controls", |ui| {
            // Button handles click internally
            if ui.button("Save").clicked() {
                self.save();
            }

            // List returns events
            if let Some(Event::Activated(idx)) = ui.events().list() {
                self.open_file(idx);
            }
        }))
    ]
}
```

**Widgets internally**:
```rust
impl UiBuilder {
    pub fn button(&mut self, label: &str) -> ButtonBuilder {
        let is_hovered = self.ctx.mouse.is_over(&self.current_id);
        let is_clicked = is_hovered && self.ctx.mouse.clicked();

        ButtonBuilder {
            label,
            is_hovered,   // For visual feedback
            is_clicked,   // Returned by .clicked()
        }
    }
}
```

### Automatic Hover Styles

Widgets automatically apply hover styles using `is_over()`:

```rust
fn render_button(&self, label: &str, id: &str, mouse: &MouseState, theme: &Theme) -> Paragraph {
    let is_hovered = mouse.is_over(id);

    let style = if is_hovered {
        Style::default()
            .fg(theme.accent_primary)
            .bg(theme.bg_surface)
    } else {
        Style::default().fg(theme.text_primary)
    };

    Paragraph::new(label).style(style)
}
```

**No app code needed** - widgets handle hover styling internally.

### Automatic Scroll Wheel

Widgets handle scroll wheel automatically when focused:

```rust
impl ListWidget {
    fn handle_mouse(&mut self, mouse: &MouseState, is_focused: bool) {
        if is_focused && mouse.is_over(&self.id) {
            if let Some(delta) = mouse.scroll_delta() {
                self.state.scroll_by(delta);
            }
        }
    }
}
```

**Apps don't need to handle scroll** - it just works!

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            // Scroll wheel works automatically when list is focused
            ui.list(&mut self.list_state, &self.items);
        }))
    ]
}
```

### Double-Click vs Single-Click

Widgets differentiate automatically:

```rust
// List widget internally
struct ListState {
    last_click_time: Instant,
    last_click_index: Option<usize>,
}

impl ListState {
    fn handle_click(&mut self, index: usize) -> ListEvent {
        let now = Instant::now();
        let is_double = self.last_click_index == Some(index)
            && now.duration_since(self.last_click_time) < Duration::from_millis(500);

        self.last_click_time = now;
        self.last_click_index = Some(index);

        if is_double {
            ListEvent::Activated(index)  // Double-click
        } else {
            ListEvent::Selected(index)   // Single-click
        }
    }
}
```

**App usage**:
```rust
if let Some(Event::Selected(idx)) = ui.events().list() {
    self.selected = idx;  // Single-click selects
}

if let Some(Event::Activated(idx)) = ui.events().list() {
    self.open_file(idx);  // Double-click opens
}
```

### Right-Click / Context Menus

Widgets can emit right-click events:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(panel("Files", |ui| {
            ui.list(&mut self.list, &self.files);

            // Check for right-click
            if let Some(Event::RightClick(idx)) = ui.events().list() {
                self.show_context_menu = true;
                self.context_menu_target = idx;
                self.context_menu_pos = ctx.mouse.position();
            }
        }))
    ];

    // Context menu as overlay layer
    if self.show_context_menu {
        layers.push(
            Layer::at(self.context_menu_pos, panel("", |ui| {
                if ui.button("Open").clicked() {
                    self.open_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Delete").clicked() {
                    self.delete_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Rename").clicked() {
                    self.show_rename_dialog = true;
                    self.show_context_menu = false;
                }
            }))
        );
    }

    layers
}
```

**Helper for common pattern**:

```rust
struct ContextMenu {
    visible: bool,
    position: (u16, u16),
    items: Vec<ContextMenuItem>,
}

impl ContextMenu {
    fn show(&mut self, pos: (u16, u16)) {
        self.visible = true;
        self.position = pos;
    }

    fn render(&mut self, ctx: &mut Context) -> Option<Layer> {
        if !self.visible { return None; }

        Some(Layer::at(self.position, panel("", |ui| {
            for item in &self.items {
                if ui.button(&item.label).clicked() {
                    (item.handler)();
                    self.visible = false;
                }
            }
        })))
    }
}
```

### MouseState API

```rust
struct MouseState {
    position: (u16, u16),
    left_button: ButtonState,
    right_button: ButtonState,
    middle_button: ButtonState,
    scroll_delta: i16,
    element_rects: HashMap<String, Rect>,
}

enum ButtonState {
    Up,
    JustPressed,   // Went down this frame
    Held,          // Down for multiple frames
    JustReleased,  // Went up this frame
}

impl MouseState {
    // Position queries
    fn position(&self) -> (u16, u16);
    fn is_over(&self, id: &str) -> bool;

    // Button queries
    fn clicked(&self) -> bool;              // Left button just pressed
    fn right_clicked(&self) -> bool;        // Right button just pressed
    fn is_dragging(&self) -> bool;          // Left button held + moved

    // Double-click detection (internal tracking)
    fn double_clicked(&self) -> bool;

    // Scroll queries
    fn scroll_delta(&self) -> i16;          // Positive = up, negative = down
}
```

**Context API**:
```rust
impl Context {
    pub fn mouse(&self) -> &MouseState;
}

// Apps/widgets use it
fn update(&mut self, ctx: &mut Context) {
    if ctx.mouse().is_over("my-element") {
        // ...
    }
}
```

### Focus Integration

Clicking an element focuses it (configurable via FocusMode):

```rust
impl Runtime {
    fn handle_mouse_click(&mut self, x: u16, y: u16) {
        // Find element at position
        if let Some(element) = self.hit_test(x, y) {
            // Focus it (if focusable)
            if element.is_focusable {
                self.focus.set_index(element.focus_index);
            }

            // Trigger click event
            self.mouse_state.left_button = ButtonState::JustPressed;
            self.invalidate();  // Re-render
        }
    }
}
```

Focus modes already designed in Focus System section:
- **Click** - Focus only on click (default)
- **Hover** - Focus follows mouse
- **HoverWhenUnfocused** - Hover focus when nothing focused

### Terminal Mouse Capture

Enable via crossterm:
```rust
crossterm::execute!(
    stdout,
    crossterm::event::EnableMouseCapture
)?;
```

Mouse events arrive through crossterm event stream:
```rust
match crossterm::event::read()? {
    Event::Mouse(MouseEvent { kind, column, row, .. }) => {
        match kind {
            MouseEventKind::Down(MouseButton::Left) => { /* ... */ }
            MouseEventKind::Up(MouseButton::Left) => { /* ... */ }
            MouseEventKind::Moved => { /* ... */ }
            MouseEventKind::ScrollUp => { /* ... */ }
            MouseEventKind::ScrollDown => { /* ... */ }
            _ => {}
        }
    }
}
```

**Key insight**: Widgets handle most mouse behavior internally. Apps only handle semantic events (file selected, button clicked, etc.) - not raw mouse events.

---

## Event-Driven Rendering

**Framework only calls `update()` when:**
- User input event (keyboard, mouse)
- Resource finishes loading
- Pub/sub message received
- Timer fires
- Explicit invalidation (`ctx.invalidate()`)

**No continuous rendering loop!** Saves CPU, battery-friendly.

---

## Background Apps

Apps can continue processing while not visible:

```rust
impl App for OperationQueue {
    fn new(ctx: &AppContext) -> Self {
        // This app runs in background
        ctx.set_lifecycle(Lifecycle::AlwaysActive);

        ctx.subscribe("operations:add", Self::on_operations_received);

        Self { queue: Vec::new() }
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // Process queue even when user is viewing other apps
        if self.current.is_none() && !self.queue.is_empty() {
            let op = self.queue.remove(0);
            self.current = Some(op.clone());
            self.progress.load(ctx, execute_operation(op));
        }

        vec![Layer::fill(self.render_queue_ui())]
    }
}
```

---

## Component System

### Terminology

**Unified "Component" naming** - no more "widget" vs "element" confusion:

- **`Component<Msg>`** - the UI tree enum (internal to framework)
- **`XxxState`** - persistent component state (ButtonState, ListState, etc.)
- **"Component"** in all documentation (not "widget" or "element")

**File structure:**
```
tui/
├── component.rs              # Component enum
├── components/
│   ├── mod.rs
│   ├── button.rs            # ButtonState
│   ├── list.rs              # ListState
│   ├── tree.rs              # TreeState
│   ├── table.rs             # TableState
│   ├── text_input.rs        # TextInputState
│   └── shared/
│       ├── mod.rs
│       ├── navigable.rs     # NavigableState (shared 2D navigation)
│       └── styling.rs       # Shared styling helpers
```

**Users never see "Component" directly:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            ui.list(&mut self.list_state, &self.items);  // Clean API
            ui.button("Save");
        }))
    ]
}
```

### NavigableState: Unified 2D Navigation

**Problem**: Current navigation is inconsistent:
- List/Tree: 1D vertical only
- Table: needs 2D (row + column)
- Scrollable: has horizontal but disconnected from navigation

**Solution**: Single `NavigableState` supporting both 1D and 2D navigation:

```rust
pub struct NavigableState {
    // Selection (None = nothing selected)
    selected_row: Option<usize>,
    selected_col: Option<usize>,  // None for 1D components

    // Scrolling (0-based offsets)
    scroll_row: usize,
    scroll_col: usize,

    // Scrolloff (vim-style, lines from edge before scrolling)
    scroll_off: usize,

    // Viewport dimensions (set by framework during render)
    viewport_rows: usize,
    viewport_cols: usize,
}

impl NavigableState {
    // 1D constructor (List, Tree, FileBrowser)
    pub fn new_1d() -> Self {
        Self {
            selected_row: None,
            selected_col: None,  // Always None for 1D
            scroll_row: 0,
            scroll_col: 0,
            scroll_off: 5,
            viewport_rows: 0,
            viewport_cols: 0,
        }
    }

    // 2D constructor (Table, Grid)
    pub fn new_2d() -> Self {
        Self {
            selected_row: None,
            selected_col: Some(0),  // Column matters for 2D
            scroll_row: 0,
            scroll_col: 0,
            scroll_off: 5,
            viewport_rows: 0,
            viewport_cols: 0,
        }
    }

    // === VERTICAL NAVIGATION ===

    pub fn navigate_up(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            if row > 0 {
                self.selected_row = Some(row - 1);
                self.adjust_scroll_vertical(row_count);
            }
        } else if row_count > 0 {
            self.selected_row = Some(0);  // Select first if nothing selected
        }
    }

    pub fn navigate_down(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            if row + 1 < row_count {
                self.selected_row = Some(row + 1);
                self.adjust_scroll_vertical(row_count);
            }
        } else if row_count > 0 {
            self.selected_row = Some(0);
        }
    }

    pub fn navigate_page_up(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            let jump = self.viewport_rows.saturating_sub(1);
            self.selected_row = Some(row.saturating_sub(jump));
            self.adjust_scroll_vertical(row_count);
        }
    }

    pub fn navigate_page_down(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            let jump = self.viewport_rows.saturating_sub(1);
            self.selected_row = Some((row + jump).min(row_count - 1));
            self.adjust_scroll_vertical(row_count);
        }
    }

    // === HORIZONTAL NAVIGATION ===

    pub fn navigate_left(&mut self, col_count: usize) {
        // Only works if selected_col is Some (2D mode)
        if let Some(col) = self.selected_col {
            if col > 0 {
                self.selected_col = Some(col - 1);
                self.adjust_scroll_horizontal(col_count);
            }
        }
    }

    pub fn navigate_right(&mut self, col_count: usize) {
        if let Some(col) = self.selected_col {
            if col + 1 < col_count {
                self.selected_col = Some(col + 1);
                self.adjust_scroll_horizontal(col_count);
            }
        }
    }

    pub fn navigate_home(&mut self) {
        // Home = start of current row (column 0)
        if self.selected_col.is_some() {
            self.selected_col = Some(0);
            self.scroll_col = 0;
        }
    }

    pub fn navigate_end(&mut self, col_count: usize) {
        // End = end of current row
        if self.selected_col.is_some() && col_count > 0 {
            self.selected_col = Some(col_count - 1);
            self.adjust_scroll_horizontal(col_count);
        }
    }

    // === SCROLLOFF ADJUSTMENT (VIM-STYLE) ===

    fn adjust_scroll_vertical(&mut self, total_rows: usize) {
        if let Some(row) = self.selected_row {
            if self.viewport_rows == 0 { return; }

            // Don't scroll if all rows fit
            if total_rows <= self.viewport_rows {
                self.scroll_row = 0;
                return;
            }

            // Scrolloff logic (keep selection N rows from edge)
            let min_scroll = row.saturating_sub(
                self.viewport_rows.saturating_sub(self.scroll_off + 1)
            );
            let max_scroll = row.saturating_sub(self.scroll_off);

            if self.scroll_row < min_scroll {
                self.scroll_row = min_scroll;
            } else if self.scroll_row > max_scroll {
                self.scroll_row = max_scroll;
            }

            // Clamp to valid range
            let max_offset = total_rows.saturating_sub(self.viewport_rows);
            self.scroll_row = self.scroll_row.min(max_offset);
        }
    }

    fn adjust_scroll_horizontal(&mut self, total_cols: usize) {
        if let Some(col) = self.selected_col {
            if self.viewport_cols == 0 { return; }

            // Same scrolloff logic, horizontal
            if total_cols <= self.viewport_cols {
                self.scroll_col = 0;
                return;
            }

            let min_scroll = col.saturating_sub(
                self.viewport_cols.saturating_sub(self.scroll_off + 1)
            );
            let max_scroll = col.saturating_sub(self.scroll_off);

            if self.scroll_col < min_scroll {
                self.scroll_col = min_scroll;
            } else if self.scroll_col > max_scroll {
                self.scroll_col = max_scroll;
            }

            let max_offset = total_cols.saturating_sub(self.viewport_cols);
            self.scroll_col = self.scroll_col.min(max_offset);
        }
    }

    // === ACCESSORS ===

    // For 1D components (List, Tree, FileBrowser)
    pub fn selected_index(&self) -> Option<usize> {
        self.selected_row
    }

    // For 2D components (Table, Grid)
    pub fn selected_cell(&self) -> Option<(usize, usize)> {
        match (self.selected_row, self.selected_col) {
            (Some(r), Some(c)) => Some((r, c)),
            _ => None
        }
    }

    pub fn scroll_offset(&self) -> (usize, usize) {
        (self.scroll_row, self.scroll_col)
    }

    // Framework sets this during render (knows viewport size)
    pub fn set_viewport_size(&mut self, rows: usize, cols: usize) {
        self.viewport_rows = rows;
        self.viewport_cols = cols;
    }
}
```

### Component State Composition

Components compose `NavigableState` for consistent behavior:

```rust
// List (1D - only vertical navigation)
pub struct ListState {
    nav: NavigableState,
    last_click: Option<(usize, Instant)>,  // For double-click detection
}

impl ListState {
    pub fn new() -> Self {
        Self {
            nav: NavigableState::new_1d(),  // selected_col = None
            last_click: None,
        }
    }

    // Delegate navigation to shared state
    pub fn navigate_up(&mut self, count: usize) {
        self.nav.navigate_up(count);
    }

    pub fn navigate_down(&mut self, count: usize) {
        self.nav.navigate_down(count);
    }

    pub fn selected(&self) -> Option<usize> {
        self.nav.selected_index()
    }

    pub fn scroll_offset(&self) -> usize {
        self.nav.scroll_offset().0  // Just vertical
    }

    // List-specific: double-click detection
    pub fn handle_click(&mut self, index: usize) -> ListEvent {
        let now = Instant::now();
        let is_double = self.last_click
            .filter(|(idx, time)| {
                *idx == index && now.duration_since(*time) < Duration::from_millis(500)
            })
            .is_some();

        self.last_click = Some((index, now));

        if is_double {
            ListEvent::Activated(index)
        } else {
            ListEvent::Selected(index)
        }
    }
}

// Table (2D - both vertical and horizontal navigation)
pub struct TableState {
    nav: NavigableState,
    rows: usize,
    cols: usize,
}

impl TableState {
    pub fn new(rows: usize, cols: usize) -> Self {
        Self {
            nav: NavigableState::new_2d(),  // selected_col = Some(0)
            rows,
            cols,
        }
    }

    // Full 2D navigation
    pub fn navigate_up(&mut self) {
        self.nav.navigate_up(self.rows);
    }

    pub fn navigate_down(&mut self) {
        self.nav.navigate_down(self.rows);
    }

    pub fn navigate_left(&mut self) {
        self.nav.navigate_left(self.cols);
    }

    pub fn navigate_right(&mut self) {
        self.nav.navigate_right(self.cols);
    }

    pub fn selected(&self) -> Option<(usize, usize)> {
        self.nav.selected_cell()
    }
}

// Tree (1D but with expansion state)
pub struct TreeState {
    nav: NavigableState,
    expanded: HashSet<String>,  // Tree-specific
    node_parents: HashMap<String, String>,
    visible_order: Vec<String>,
}

impl TreeState {
    pub fn new() -> Self {
        Self {
            nav: NavigableState::new_1d(),
            expanded: HashSet::new(),
            node_parents: HashMap::new(),
            visible_order: Vec::new(),
        }
    }

    // Delegate navigation
    pub fn navigate_up(&mut self) {
        self.nav.navigate_up(self.visible_order.len());
    }

    pub fn navigate_down(&mut self) {
        self.nav.navigate_down(self.visible_order.len());
    }

    // Tree-specific: expansion
    pub fn toggle(&mut self, id: &str) {
        if self.expanded.contains(id) {
            self.expanded.remove(id);
        } else {
            self.expanded.insert(id.to_string());
        }
    }
}
```

### Shared Styling Helpers

Consistent visual feedback across all focusable components:

```rust
// components/shared/styling.rs
pub fn apply_focus_style(base: Style, is_focused: bool, theme: &Theme) -> Style {
    if is_focused {
        base.fg(theme.accent_primary).bg(theme.bg_surface)
    } else {
        base
    }
}
```

**Note**: No separate hover styling. Hover is only used for:
- Click targeting (which component is under mouse)
- Tooltips (show on hover without focusing)
- FocusMode behavior (hover can trigger focus)

Visual feedback is focus-only - cleaner and less noisy.

### Benefits

✅ **Consistent navigation** - List, Tree, Table, FileBrowser all use same logic
✅ **Scrolloff works everywhere** - vim-style scrolling behavior unified
✅ **2D support built-in** - Table gets full keyboard navigation
✅ **Less duplication** - Navigation written once, tested once
✅ **Easy to extend** - New navigable components just compose NavigableState

---

## Lifecycle & App Management

### Simplified Lifecycle Model

In V2's immediate mode architecture, lifecycle is dramatically simpler than V1:

**V1 problems:**
- Two policies (QuitPolicy + SuspendPolicy) for one event
- Dead code (LoadingScreen's `on_suspend` never called due to `AlwaysActive`)
- Unused features (QuittingRequested, QuitOnIdle, KillReason)
- Unclear semantics (what does "Sleep" mean?)

**V2 solution:** One policy, clear semantics.

### Lifecycle Policy

```rust
trait App: 'static {
    fn new(ctx: &AppContext) -> Self;
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer>;

    // Lifecycle policy (static)
    fn lifecycle() -> Lifecycle {
        Lifecycle::Destroy  // Default: destroy when navigating away
    }

    // Lifecycle hooks (sync only)
    fn can_quit(&self) -> Result<(), String> { Ok(()) }
    fn quit_requested(&mut self) { }  // Called when vetoed, now foreground
    fn on_background(&mut self) { }   // Moved to background
    fn on_foreground(&mut self) { }   // Returned to foreground
    fn on_destroy(&mut self) { }      // About to be destroyed
}

enum Lifecycle {
    /// Destroy immediately when navigating away
    Destroy,

    /// Keep in background - still receive events and call update()
    /// (pub/sub, timers, async completions - but NOT keyboard/mouse)
    Background,
}
```

### When update() Is Called

**Foreground app:**
```rust
// update() called on:
- User input (keyboard, mouse)       ✓
- Pub/sub messages                   ✓
- Timers                             ✓
- Async task completion              ✓
```

**Background app:**
```rust
// update() called on:
- User input (keyboard, mouse)       ✗ (no longer foreground)
- Pub/sub messages                   ✓
- Timers                             ✓
- Async task completion              ✓
```

### Runtime Navigation Behavior

```rust
impl Runtime {
    fn navigate_to(&mut self, target_app: AppId) {
        let current = self.active_app;

        // Handle current app based on its lifecycle policy
        match current.lifecycle() {
            Lifecycle::Destroy => {
                current.on_destroy();
                self.apps.remove(current);  // Destroyed
            }
            Lifecycle::Background => {
                current.on_background();
                self.background_apps.insert(current);  // Keep alive
            }
        }

        // Switch to target
        if self.background_apps.contains(target) {
            target.on_foreground();  // Resuming from background
        } else {
            // Create new instance
            target = Target::new(ctx);
        }

        self.active_app = target;
    }
}
```

### Global Quit Coordination

Runtime checks all apps (foreground + background) before quitting:

```rust
impl Runtime {
    fn handle_global_quit(&mut self) {
        // 1. Check foreground app first
        if let Err(reason) = self.active_app.can_quit() {
            self.active_app.quit_requested();
            return;  // Let app show its modal
        }

        // 2. Check all background apps
        for (app_id, app) in &self.background_apps {
            if let Err(reason) = app.can_quit() {
                // Navigate to this app
                self.navigate_to(app_id);
                // Notify it
                app.quit_requested();
                return;  // Let app show its modal
            }
        }

        // 3. All apps OK - call on_destroy on all, then quit
        for app in &mut self.apps {
            app.on_destroy();
        }

        // Give tokio 1 second for Drop impls to cleanup
        tokio::time::timeout(Duration::from_secs(1), async {
            // Let async tasks finish cleanup
        }).await;

        std::process::exit(0);
    }
}
```

**Example: OperationQueue blocks quit**

```rust
impl App for OperationQueue {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background  // Run in background
    }

    fn can_quit(&self) -> Result<(), String> {
        if !self.currently_running.is_empty() {
            Err(format!("{} operations in progress", self.currently_running.len()))
        } else {
            Ok(())
        }
    }

    fn quit_requested(&mut self) {
        // Runtime just brought us to foreground - show modal
        self.show_quit_confirm = true;
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        let mut layers = vec![/* main UI */];

        if self.show_quit_confirm {
            layers.push(
                ConfirmationModal::new(
                    "Quit Application?",
                    format!("{} operations running. Cancel and quit?", self.currently_running.len())
                )
                .on_yes(Self::handle_force_quit)
                .on_no(Self::handle_cancel_quit)
                .build()
            );
        }

        layers
    }

    fn handle_force_quit(&mut self, ctx: &mut Context) {
        // Cancel operations
        for id in &self.currently_running {
            self.mark_cancelled_sync(id);
        }
        ctx.quit();
    }

    fn handle_cancel_quit(&mut self) {
        self.show_quit_confirm = false;
        // User stays in queue, can monitor operations
    }

    fn on_destroy(&mut self) {
        // Quick sync cleanup - mark operations as cancelled in DB
        for id in &self.currently_running {
            self.mark_cancelled_sync(id);
        }
        // Tokio tasks dropped when app drops
        // Runtime gives them 1 second to finish cleanup
    }
}
```

**User experience:**

```rust
// Scenario: User presses Ctrl+Q while queue in background
// 1. Runtime checks foreground app → OK
// 2. Runtime checks OperationQueue → VETO ("3 operations running")
// 3. Runtime navigates to OperationQueue
// 4. Runtime calls queue.quit_requested()
// 5. Queue shows modal: "3 operations running. Cancel and quit?"
// 6. User sees which operations, can choose
```

### Memory Pressure Management

Runtime automatically cleans up old background apps:

```rust
impl Runtime {
    const MAX_BACKGROUND_APPS: usize = 10;

    fn check_memory_pressure(&mut self) {
        if self.background_apps.len() > Self::MAX_BACKGROUND_APPS {
            // Find oldest background app (least recently active)
            let oldest = self.background_apps
                .iter()
                .min_by_key(|app| app.last_active_time)
                .unwrap();

            log::info!("Memory pressure - destroying oldest background app: {:?}", oldest.id);

            // Give app chance to cleanup
            oldest.on_destroy();

            // Remove from runtime
            self.background_apps.remove(oldest.id);
        }
    }
}
```

**Apps don't specify cleanup timers** - that's runtime policy, not app policy.

### Hook Details

#### can_quit() - Veto Quit Attempts

```rust
fn can_quit(&self) -> Result<(), String> {
    if self.has_unsaved_changes {
        Err("You have unsaved changes".to_string())
    } else {
        Ok(())
    }
}
```

- Called by runtime when user tries to quit
- Check foreground app first, then background apps
- First app to veto is brought to foreground

#### quit_requested() - Handle Veto

```rust
fn quit_requested(&mut self) {
    // Runtime just brought us to foreground
    self.show_quit_confirm = true;  // Show modal
}
```

- Only called if `can_quit()` returned `Err`
- App is now foreground (runtime navigated to it)
- App shows modal explaining why it can't quit
- App provides options (force quit, wait, cancel)

#### on_background() - Moved to Background

```rust
fn on_background(&mut self) {
    // Clear state that shouldn't persist in background
    self.countdown_ticks = None;
    self.show_temporary_modal = false;
}
```

- Called when user navigates away from this app
- Only called if `lifecycle() == Background`
- App still receives pub/sub, timers, async completions
- App can still call `ctx.navigate()` to come back to foreground

#### on_foreground() - Returned to Foreground

```rust
fn on_foreground(&mut self) {
    // Refresh data if stale
    if self.last_refresh.elapsed() > Duration::from_secs(60) {
        self.refresh();
    }
}
```

- Called when user navigates back to this app
- Only called if app was in background (not freshly created)
- App should refresh any stale data

#### on_destroy() - About to Be Destroyed

```rust
fn on_destroy(&mut self) {
    // Quick sync cleanup only
    self.flush_buffers_sync();
    self.save_state_sync();
    // Drop impl handles async cleanup
}
```

- Called before app is removed from runtime
- **Sync only** - no async allowed
- Runtime gives 1 second grace period for Drop impls
- Use for quick cleanup (DB writes, buffer flushes)
- Tokio tasks are automatically dropped

### Why Hooks Are Sync

**Problem with async hooks:**
```rust
async fn on_destroy(&mut self) {
    self.log_buffer.flush().await;  // Blocks runtime!
    // UI frozen, user can't cancel, no progress feedback
}
```

**Solution: Sync hooks + grace period**
```rust
fn on_destroy(&mut self) {
    self.log_buffer.flush_sync();  // Quick sync flush
    // Or: mark for cleanup, Drop impl handles rest
}

impl Drop for MyApp {
    fn drop(&mut self) {
        // Async cleanup via Drop
        // Runtime gives 1 second grace period
    }
}
```

**Benefits:**
- ✅ UI stays responsive
- ✅ User can see progress via modals
- ✅ Apps control cleanup UX
- ✅ Runtime provides grace period for Drop

### Migration from V1

**V1 → V2 equivalents:**

```rust
// v1: QuitPolicy::Sleep + SuspendPolicy::AlwaysActive
impl App for OperationQueue {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background
    }
    // No on_background needed - just keep running
}

// v1: QuitPolicy::Sleep + SuspendPolicy::Suspend + on_suspend
impl App for LoadingScreen {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background
    }

    fn on_background(&mut self) {
        // Clear countdown to prevent stale navigation
        self.countdown_ticks = None;
        self.target_app = None;
    }
}

// v1: QuitPolicy::QuitOnExit or SuspendPolicy::QuitOnSuspend
impl App for ErrorScreen {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Destroy  // Default
    }
}
```

### Benefits

✅ **Simpler mental model** - One policy (Destroy or Background)
✅ **No dead code** - LoadingScreen scenario works correctly
✅ **Clearer semantics** - "Destroy or keep in background" is obvious
✅ **Background apps block quit** - Queue can veto quit even when not foreground
✅ **Memory managed by runtime** - Apps don't think about cleanup timers
✅ **Sync hooks** - UI stays responsive, apps show progress modals

---

## Modal System

### Modals Are Just Layers

**Core concept:** Modals are not a special framework type - they're just layers with specific properties:

```rust
struct Layer {
    element: Component,
    area: LayerArea,
    dim_below: bool,      // Modals set this to true
    blocks_input: bool,   // Modals set this to true
}
```

**Creating a modal:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(self.main_ui())
    ];

    // Modal is just another layer
    if self.show_confirm {
        layers.push(
            Layer::centered(50, 15, panel("Confirm?", |ui| {
                ui.text("Are you sure?");
                ui.button("Yes").on_click(Self::handle_yes);
                ui.button("No").on_click(Self::handle_no);
            }))
            .dim_below(true)      // Dims everything below this layer
            .blocks_input(true)   // Prevents interaction with lower layers
        );
    }

    layers
}
```

**Apps control visibility** - framework doesn't auto-show/hide modals:

```rust
struct MyApp {
    show_confirm: bool,  // App owns this flag
    // ...
}

fn handle_delete(&mut self, ctx: &mut Context) {
    self.show_confirm = true;  // Show modal
}

fn handle_yes(&mut self, ctx: &mut Context) {
    self.delete_file();
    self.show_confirm = false;  // Hide modal
}

fn handle_no(&mut self, ctx: &mut Context) {
    self.show_confirm = false;  // Hide modal
}
```

### Hybrid Approach: Pattern + Optional Helpers

**Modals are a pattern, not a framework concept.**

Apps can choose:
1. **Raw layers** - maximum flexibility for custom modals
2. **Builder helpers** - convenience for common patterns

**File structure:**
```
tui/
├── layer.rs                  # Layer type (core primitive)
└── modals/                   # Optional builder helpers
    ├── mod.rs
    ├── confirmation.rs       # ConfirmationModal builder
    ├── error.rs              # ErrorModal builder
    ├── loading.rs            # LoadingModal builder (with spinner)
    └── help.rs               # HelpModal (keybinding viewer)
```

### Raw Layers (Maximum Flexibility)

For custom modals, just use layers directly:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![Layer::fill(self.main_ui())];

    // Custom modal - full control over layout
    if self.show_settings {
        layers.push(
            Layer::centered(80, 30, panel("Settings", |ui| {
                ui.text("Theme:");
                ui.select(&mut self.theme_select, &["Mocha", "Latte"]);

                ui.text("");
                ui.text("Focus Mode:");
                ui.select(&mut self.focus_mode_select, &["Click", "Hover"]);

                ui.text("");
                if ui.button("Save").clicked() {
                    self.save_settings();
                    self.show_settings = false;
                }
                if ui.button("Cancel").clicked() {
                    self.show_settings = false;
                }
            }))
            .dim_below(true)
            .blocks_input(true)
        );
    }

    layers
}
```

### Builder Helpers (Convenience)

For common patterns, use builder types:

```rust
// tui/modals/confirmation.rs
pub struct ConfirmationModal {
    title: String,
    message: String,
    on_yes: Option<fn()>,
    on_no: Option<fn()>,
    on_cancel: Option<fn()>,  // Called on Esc
    width: u16,
    height: u16,
}

impl ConfirmationModal {
    pub fn new(title: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            title: title.into(),
            message: message.into(),
            on_yes: None,
            on_no: None,
            on_cancel: None,
            width: 50,
            height: 15,
        }
    }

    pub fn on_yes(mut self, handler: fn()) -> Self {
        self.on_yes = Some(handler);
        self
    }

    pub fn on_no(mut self, handler: fn()) -> Self {
        self.on_no = Some(handler);
        self
    }

    pub fn on_cancel(mut self, handler: fn()) -> Self {
        self.on_cancel = Some(handler);
        self
    }

    pub fn width(mut self, width: u16) -> Self {
        self.width = width;
        self
    }

    pub fn build(self) -> Layer {
        Layer::centered(self.width, self.height, panel(&self.title, |ui| {
            ui.text(&self.message);
            ui.text("");

            if let Some(yes) = self.on_yes {
                if ui.button("Yes").clicked() {
                    yes();
                }
            }

            if let Some(no) = self.on_no {
                if ui.button("No").clicked() {
                    no();
                }
            }
        }))
        .dim_below(true)
        .blocks_input(true)
        .on_escape(self.on_cancel)  // Register Esc handler
    }
}
```

**App usage:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![Layer::fill(self.main_ui())];

    if self.show_delete_confirm {
        layers.push(
            ConfirmationModal::new("Delete File?", "This cannot be undone")
                .on_yes(Self::handle_confirm_delete)
                .on_no(Self::handle_cancel_delete)
                .on_cancel(Self::handle_cancel_delete)  // Esc = same as No
                .width(60)
                .build()
        );
    }

    layers
}

fn handle_confirm_delete(&mut self, ctx: &mut Context) {
    self.delete_file();
    self.show_delete_confirm = false;
}

fn handle_cancel_delete(&mut self, ctx: &mut Context) {
    self.show_delete_confirm = false;
}
```

### Built-in Modal Helpers

Framework provides builders for common patterns:

#### ConfirmationModal

Yes/No dialogs:

```rust
ConfirmationModal::new("Delete?", "This cannot be undone")
    .on_yes(Self::handle_yes)
    .on_no(Self::handle_no)
    .on_cancel(Self::handle_no)
    .build()
```

#### ErrorModal

Error display with dismiss button:

```rust
ErrorModal::new("Failed to Save", &error_message)
    .on_dismiss(Self::handle_error_dismiss)
    .build()
```

#### LoadingModal

Loading spinner with optional progress:

```rust
// Simple spinner
LoadingModal::new("Loading...")
    .build()

// With progress
LoadingModal::new("Processing files...")
    .progress(self.completed, self.total)
    .build()
```

#### HelpModal

Keybinding viewer (auto-populated from app keybinds):

```rust
HelpModal::new()
    .app_keybinds(MyApp::keybinds())
    .build()
```

### Modal Dismissal (Esc Behavior)

**Apps control when modals close** - framework doesn't auto-dismiss.

**Progressive Unfocus revised:**
```rust
impl Runtime {
    fn handle_escape(&mut self) {
        // 1. If something focused on top layer, blur it
        if self.focus.has_focus() {
            self.focus.blur();
            return;
        }

        // 2. If unfocused, dispatch to app via keybinds
        // Apps can:
        // - Close modals (via on_cancel handler)
        // - Quit app
        // - Do nothing
        self.dispatch_keybind("escape");
    }
}
```

**Modal builders register Esc handler:**
```rust
layers.push(
    ConfirmationModal::new("Delete?", "Sure?")
        .on_cancel(Self::handle_cancel)  // Called when Esc pressed
        .build()
);

fn handle_cancel(&mut self, ctx: &mut Context) {
    self.show_confirm = false;  // App controls dismissal
    self.cleanup_modal_state();
}
```

**Apps can also handle Esc globally:**
```rust
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("close", "Close modal/quit", default_key!("Esc"), Self::handle_escape)
    }
}

fn handle_escape(&mut self, ctx: &mut Context) {
    if self.show_any_modal {
        // Close modal
        self.show_confirm = false;
        self.show_error = false;
        // ...
    } else {
        // Quit app
        ctx.quit();
    }
}
```

### Context Menu Pattern

Right-click context menus are just layers positioned at mouse:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(panel("Files", |ui| {
            ui.list(&mut self.list, &self.files);

            if let Some(Event::RightClick(idx)) = ui.events().list() {
                self.show_context_menu = true;
                self.context_menu_target = idx;
                self.context_menu_pos = ctx.mouse.position();
            }
        }))
    ];

    // Context menu as overlay layer
    if self.show_context_menu {
        layers.push(
            Layer::at(self.context_menu_pos, panel("", |ui| {
                if ui.button("Open").clicked() {
                    self.open_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Delete").clicked() {
                    self.show_delete_confirm = true;
                    self.show_context_menu = false;
                }
                if ui.button("Rename").clicked() {
                    self.show_rename_dialog = true;
                    self.show_context_menu = false;
                }
            }))
            .dim_below(false)     // Context menus don't dim
            .blocks_input(true)   // But they do block clicks
        );
    }

    layers
}
```

**Optional helper:**
```rust
// tui/modals/context_menu.rs
pub struct ContextMenu {
    items: Vec<(&'static str, fn())>,
    position: (u16, u16),
}

impl ContextMenu {
    pub fn new(position: (u16, u16)) -> Self {
        Self { items: vec![], position }
    }

    pub fn item(mut self, label: &'static str, handler: fn()) -> Self {
        self.items.push((label, handler));
        self
    }

    pub fn build(self) -> Layer {
        Layer::at(self.position, panel("", |ui| {
            for (label, handler) in &self.items {
                if ui.button(label).clicked() {
                    handler();
                }
            }
        }))
        .dim_below(false)
        .blocks_input(true)
    }
}

// Usage
layers.push(
    ContextMenu::new(self.context_menu_pos)
        .item("Open", Self::handle_open)
        .item("Delete", Self::handle_delete)
        .item("Rename", Self::handle_rename)
        .build()
);
```

### Benefits

✅ **Simple mental model** - modals are just layers with flags
✅ **Maximum flexibility** - raw layers available for custom modals
✅ **Convenience helpers** - builders for common patterns (confirm, error, loading)
✅ **App-controlled** - apps decide when to show/hide modals
✅ **Consistent UI** - builders provide standard styling (but customizable)
✅ **Easy to extend** - adding new modal types is just adding a builder

---

## Color System (OKLCH)

**Why OKLCH over RGB/HSL:**
- **Perceptually uniform** - 50% dimming looks like 50% to human eye (HSL doesn't)
- **Consistent saturation** - Red and blue at same chroma look equally vibrant (HSL fails)
- **Better gradients** - No weird hue shifts when interpolating
- **Easy manipulation** - Brightness, saturation, hue are independent

**Implementation:**

```rust
#[derive(Clone, Copy)]
struct Color {
    l: f32,  // Lightness: 0.0 - 1.0
    c: f32,  // Chroma: 0.0 - 0.4 (practical max)
    h: f32,  // Hue: 0.0 - 360.0
}

impl Color {
    // Easy brightness manipulation
    fn dim(&self, factor: f32) -> Self {
        Color {
            l: (self.l * factor).clamp(0.0, 1.0),
            c: self.c,
            h: self.h,
        }
    }

    // Fade toward background
    fn fade(&self, background: &Color, alpha: f32) -> Self {
        Color {
            l: self.l * alpha + background.l * (1.0 - alpha),
            c: self.c * alpha,  // Desaturate when fading
            h: self.h,
        }
    }

    // Saturate/desaturate
    fn with_chroma(&self, c: f32) -> Self {
        Color { c: c.clamp(0.0, 0.4), ..*self }
    }

    // Convert to Ratatui RGB for rendering
    fn to_rgb(&self) -> RatatuiColor {
        let (r, g, b) = oklch_to_rgb(self.l, self.c, self.h);
        RatatuiColor::Rgb(r, g, b)
    }
}

// Theme becomes OKLCH-based
struct Theme {
    bg_base: Color,      // L=0.2, C=0.02, H=240
    text_primary: Color, // L=0.9, C=0.02, H=240
    accent: Color,       // L=0.7, C=0.15, H=200
    // ...
}

impl Theme {
    // Easy to generate variations
    fn dim_overlay(&self) -> Color {
        self.bg_base.dim(0.5)  // Perceptually 50% darker
    }

    fn hover_accent(&self) -> Color {
        self.accent.dim(1.2)  // 20% brighter
    }
}
```

---

## Animation System

**Terminal constraints:**
- Character grid (no sub-cell positioning)
- ~60fps max practical
- But: Smooth color interpolation works great!

### Frame Timing (Dynamic Mode Switching)

**Two rendering modes:**

1. **Event-Driven (Default - 0% CPU)**
   - Runtime blocks waiting for events
   - No rendering until event arrives
   - Perfect for battery life

2. **Frame-Driven (Only When Animating)**
   - Runtime renders at 60fps
   - Switches automatically when animations active
   - Back to event-driven when animations complete

```rust
impl Runtime {
    async fn run(&mut self) {
        loop {
            // Check if any animations are active
            let animating = self.has_active_animations();

            if animating {
                // FRAME-DRIVEN: Render at 60fps
                tokio::select! {
                    Some(event) = self.events.recv() => {
                        self.handle_event(event);
                    }
                    _ = tokio::time::sleep(Duration::from_millis(16)) => {
                        // Time for next animation frame
                    }
                }

                self.render();  // Interpolate next frame

            } else {
                // EVENT-DRIVEN: Block until event (could be minutes!)
                let event = self.events.recv().await;  // BLOCKS - 0% CPU
                self.handle_event(event);

                self.render();  // Render once
            }
        }
    }

    fn has_active_animations(&self) -> bool {
        self.toast_manager.has_animations() ||
        self.animation_manager.has_active()
    }
}
```

**CPU impact:**
- Idle app: **0% CPU** (thread blocked on event)
- Animating: **~1-2% CPU** (60fps × minimal work)
- Switches automatically - no user intervention

### Toast System (Global)

**Managed by framework, not apps:**

```rust
// Apps just call methods
async fn handle_save(&mut self, ctx: &mut Context) {
    match self.save().await {
        Ok(_) => ctx.toast.success("Saved!"),
        Err(e) => ctx.toast.error(format!("Failed: {}", e)),
    }
}

// Runtime automatically adds toast layer
impl Runtime {
    fn render(&mut self) {
        let mut all_layers = vec![];

        all_layers.push(Layer::dock_top(3, self.render_header()));
        all_layers.extend(self.active_app.update());

        // System-managed toast layer (not app-managed!)
        if let Some(toast_layer) = self.toast_manager.render() {
            all_layers.push(toast_layer);
        }

        self.renderer.render(&all_layers);
    }
}
```

**Toast animations:**

```rust
struct Toast {
    message: String,
    level: ToastLevel,
    created: Instant,
    state: ToastState,
}

enum ToastState {
    Entering,   // Sliding in from right
    Visible,    // Fully visible
    Exiting,    // Fading out
}

fn render_toast(&self, toast: &Toast) -> Element {
    let age = Instant::now().duration_since(toast.created);

    // Calculate animation values
    let (offset_y, alpha) = match toast.state {
        ToastState::Entering => {
            let t = (age.as_secs_f32() / 0.2).clamp(0.0, 1.0);
            let eased = 1.0 - (1.0 - t).powi(3);  // EaseOut
            (((1.0 - eased) * 3.0) as i16, eased)
        }
        ToastState::Visible => (0, 1.0),
        ToastState::Exiting => {
            let t = (age.as_secs_f32() / 0.3).clamp(0.0, 1.0);
            (0, 1.0 - t)
        }
    };

    // Fade colors based on alpha
    let fg = toast_color.fade(&theme.bg_base, alpha);
    let bg = theme.bg_surface.fade(&theme.bg_base, alpha * 0.9);

    panel(&toast.message)
        .style(Style::fg(fg.to_rgb()).bg(bg.to_rgb()))
        .offset_y(offset_y)
}
```

**Toast API:**

```rust
// Simple usage
ctx.toast.info("Loading...");
ctx.toast.success("Done!");
ctx.toast.warning("Check this");
ctx.toast.error("Failed!");

// Custom duration
ctx.toast.info("Quick message").duration(Duration::from_secs(1));

// With action button
ctx.toast.info("File saved")
    .action("Undo", Self::handle_undo);
```

### Drag & Drop

```rust
struct DragState {
    dragging: Option<DragData>,
    current_pos: (u16, u16),
}

struct DragData {
    item_index: usize,
    item_snapshot: Element,
}

impl App for MyApp {
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        let mut layers = vec![
            Layer::fill(panel("Items", |ui| {
                ui.list(&mut self.list_state, &self.items)
                    .draggable(true)
                    .on_drag_start(|idx| {
                        self.drag_state.start_drag(idx, &self.items[idx]);
                    })
                    .on_drop(|from_idx, to_idx| {
                        self.items.swap(from_idx, to_idx);
                    });
            }))
        ];

        // Dragged item as overlay layer
        if let Some(drag) = &self.drag_state.dragging {
            layers.push(
                Layer::at(self.drag_state.current_pos, drag.item_snapshot.clone())
                    .alpha(0.8)  // Semi-transparent
            );
        }

        layers
    }
}
```

### Animation Easing

```rust
enum Easing {
    Linear,
    EaseOut,          // Decelerate (feels natural)
    EaseInOut,        // S-curve
    Spring(f32),      // Bouncy (damping factor)
}

impl Easing {
    fn apply(&self, t: f32) -> f32 {
        match self {
            Easing::Linear => t,
            Easing::EaseOut => 1.0 - (1.0 - t).powi(3),
            Easing::EaseInOut => {
                if t < 0.5 {
                    4.0 * t * t * t
                } else {
                    1.0 - (-2.0 * t + 2.0).powi(3) / 2.0
                }
            }
            Easing::Spring(damping) => {
                1.0 - f32::exp(-damping * t) * (2.0 * PI * 1.5 * t).cos()
            }
        }
    }
}
```

---

## Background Work + Invalidation

Apps can do work while user is idle and trigger UI updates:

```rust
// Pattern 1: Progress updates
async fn process_batch(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();
    let progress = Arc::new(AtomicU32::new(0));
    let progress_clone = progress.clone();

    ctx.spawn(async move {
        for i in 0..100 {
            process_step(i).await;
            progress_clone.store(i, Ordering::Relaxed);
            invalidator.invalidate();  // Trigger re-render
        }
    });

    self.progress = progress;
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let progress = self.progress.load(Ordering::Relaxed);

    vec![
        Layer::fill(panel("Processing", |ui| {
            ui.progress_bar(progress, 100);
        }))
    ]
}

// Pattern 2: File watching
async fn watch_config(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();

    ctx.spawn(async move {
        let mut watcher = notify::watcher(...);
        while watcher.changed().await {
            invalidator.invalidate();  // File changed, re-render
        }
    });
}

// Pattern 3: Periodic polling
async fn poll_api(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();

    ctx.spawn(async move {
        loop {
            fetch_and_update().await;
            invalidator.invalidate();
            tokio::time::sleep(Duration::from_secs(5)).await;
        }
    });
}
```

**Event Sources (all wake runtime from sleep):**
- Keyboard/mouse events (OS wakes us, ~1-3ms latency)
- Resource completion (async task finishes)
- Pub/sub messages (from other apps)
- Timers (tokio timers)
- Explicit invalidation (from background tasks)

**Total keypress latency: ~7-11ms** (competitive with native GUIs)

---

## Component Interaction Patterns

**In immediate mode, component interaction is dramatically simpler than V1's message-passing architecture.**

### V1 Problems

**Problem 1: Message explosion**

Every component interaction needs 3-5 Msg enum variants:

```rust
enum Msg {
    SourceTreeNavigate(KeyCode),     // Navigate in tree
    SourceTreeSelect(String),         // Select node
    SourceTreeToggle(String),         // Expand/collapse
    SourceTreeViewportHeight(usize),  // on_render callback
    SourceTreeClicked(String),        // Mouse click

    // Repeat for EVERY component in your app
    TargetTreeNavigate(KeyCode),
    TargetTreeSelect(String),
    TargetTreeToggle(String),
    TargetTreeViewportHeight(usize),
    TargetTreeClicked(String),

    // ...dozens more
}
```

**Result**: Msg enum bloat, ceremony, hard to maintain.

**Problem 2: on_render callbacks hack**

Scrollable components need viewport dimensions, but dimensions aren't known until render completes:

```rust
// App uses hardcoded fallback
state.list_state.set_viewport_height(20);  // GUESS! Wrong until first render

// Widget requests real dimensions via callback
Element::List {
    on_render: Some(|actual_height| Msg::SetViewportHeight(actual_height)),
    // ...
}

// Next frame, app gets real height and updates state
Msg::SetViewportHeight(h) => {
    state.list_state.set_viewport_height(h);
    Command::None
}
```

**Result**: 1-frame delay, hardcoded fallbacks, boilerplate messages.

**Problem 3: State management boilerplate**

Apps must manually track component state (cursor position, scroll, etc.):

```rust
struct MyApp {
    name_value: String,              // The actual data
    name_cursor: usize,              // Cursor position
    name_scroll: usize,              // Scroll offset
    name_selection: Option<(usize, usize)>,  // Selection range
    // Repeat for every text input...
}
```

**Result**: Apps manage low-level details they shouldn't care about.

### V2 Solution: Callbacks + Internal State

**Three key improvements:**

1. **Components manage internal state** (cursor, scroll, focus)
2. **Callbacks replace message passing** (direct method calls)
3. **Dimensions known during construction** (no on_render hacks)

```rust
struct MyApp {
    name: String,           // Just the data
    items: Vec<Item>,       // Just the data
    selected: Option<usize>, // App-level selection
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            // Component manages cursor/scroll internally
            // Dimensions known immediately
            // Callbacks called directly
            ui.text_input(&mut self.name)
                .placeholder("Enter name")
                .on_change(Self::handle_name_change)
                .on_submit(Self::handle_submit);

            ui.list(&self.items)
                .on_select(Self::handle_select)
                .on_activate(Self::handle_activate);
        }))
    ]
}

fn handle_submit(&mut self, ctx: &mut Context) {
    println!("Submitted: {}", self.name);
}

fn handle_select(&mut self, ctx: &mut Context, index: usize) {
    self.selected = Some(index);
}
```

**No messages, no state management boilerplate, no dimension hacks.**

### Callback Patterns by Component Type

V2 uses consistent callback patterns across all components:

#### Simple Components (Button, Link)

Single-action components with one callback:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Controls", |ui| {
            ui.button("Save")
                .on_click(Self::handle_save);

            ui.button("Cancel")
                .on_click(Self::handle_cancel);

            ui.link("Learn more")
                .on_click(Self::handle_learn_more);
        }))
    ]
}

fn handle_save(&mut self, ctx: &mut Context) {
    self.save();
}

fn handle_cancel(&mut self, ctx: &mut Context) {
    ctx.navigate_back();
}
```

**Single callback** - no complexity.

#### Text Input

Multiple callbacks for different events:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name)
                .placeholder("Enter name")
                .on_change(Self::handle_name_change)  // Called on each keystroke
                .on_submit(Self::handle_submit);       // Called on Enter
        }))
    ]
}

fn handle_name_change(&mut self, ctx: &mut Context) {
    // self.name already updated by component
    // Optional: validate, update suggestions, etc.
}

fn handle_submit(&mut self, ctx: &mut Context) {
    self.submit_form();
}
```

**Multiple callbacks** - component manages cursor/scroll, app handles semantics.

#### Complex Components (List, Tree, Table)

Multiple callbacks for rich interactions:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Files", |ui| {
            ui.list(&self.files)
                .on_select(Self::handle_select)        // Arrow keys or click
                .on_activate(Self::handle_activate)    // Enter or double-click
                .on_right_click(Self::handle_context); // Right-click
        }))
    ]
}

fn handle_select(&mut self, ctx: &mut Context, index: usize) {
    // Single-click - update preview
    self.selected_file = Some(index);
    self.preview_file(index);
}

fn handle_activate(&mut self, ctx: &mut Context, index: usize) {
    // Double-click or Enter - open file
    self.open_file(index);
}

fn handle_context(&mut self, ctx: &mut Context, index: usize) {
    // Show context menu
    self.show_context_menu = true;
    self.context_menu_target = index;
    self.context_menu_pos = ctx.mouse.position();
}
```

**Callback signatures** - parameters vary by component:

```rust
// Button
fn on_click(&mut self, ctx: &mut Context);

// Text Input
fn on_change(&mut self, ctx: &mut Context);
fn on_submit(&mut self, ctx: &mut Context);

// List
fn on_select(&mut self, ctx: &mut Context, index: usize);
fn on_activate(&mut self, ctx: &mut Context, index: usize);
fn on_right_click(&mut self, ctx: &mut Context, index: usize);

// Tree
fn on_select(&mut self, ctx: &mut Context, node_id: String);
fn on_toggle(&mut self, ctx: &mut Context, node_id: String);
fn on_activate(&mut self, ctx: &mut Context, node_id: String);

// Table
fn on_select(&mut self, ctx: &mut Context, row: usize, col: usize);
fn on_activate(&mut self, ctx: &mut Context, row: usize, col: usize);
```

**Pattern consistency:**
- **on_select** = navigation (arrow keys, single-click)
- **on_activate** = action (Enter, double-click)
- **on_right_click** = context menu
- **on_toggle** = expand/collapse (Tree-specific)

### Component State Management

**V1 problem**: App must manually update component state for every navigation action:

```rust
// V1 - manual state management for EVERY key
Msg::ListNavigate(key) => {
    match key {
        KeyCode::Up => state.list_state.navigate_up(),
        KeyCode::Down => state.list_state.navigate_down(),
        KeyCode::PageUp => state.list_state.page_up(),
        KeyCode::PageDown => state.list_state.page_down(),
        // ...
    }
    Command::None
}
```

**V2 solution**: Components handle all navigation internally:

```rust
// V2 - zero navigation code
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            ui.list(&self.items)
                .on_activate(Self::handle_activate);

            // Arrow keys, scroll wheel, PageUp/Down all work automatically
            // App only handles semantic actions
        }))
    ]
}
```

**Automatic behaviors** (no app code needed):
- Arrow keys update selection & scroll
- Scroll wheel updates scroll offset
- PageUp/PageDown navigate by page
- Home/End jump to start/end
- Tab/Shift-Tab move focus between components
- Escape blurs focus
- Mouse click selects item
- Double-click activates item

**Callbacks only for semantic actions**:
- Open file (activate)
- Show context menu (right-click)
- Custom business logic (select with side effects)

Apps work with **data only**, components handle **UI state**.

### Component State: Automatic vs Semantic

**Key distinction:** Not all component state is managed the same way.

#### Automatic State (Component-Managed, Hidden)

Low-level UI state that apps shouldn't care about:
- **Text cursor position** - Where the cursor is within text input
- **Scroll offset** - Pixel/character offset for scrolling
- **Hover state** - Which element mouse is over
- **Focus ring position** - Internal focus tracking

**Components manage this entirely** - apps never see or control it.

```rust
// App just provides the value
ui.text_input(&mut self.name)
    .on_submit(Self::handle_submit);

// Component handles cursor, scroll, selection internally
```

#### Semantic State (App-Managed, Exposed)

High-level state that apps need to query or control:
- **Tree expansion** - Which nodes are expanded/collapsed
- **Selection** - Which item is selected
- **Sort order** - How table is sorted
- **Column widths** - Table column sizes

**Apps manage via state objects** - components read and mutate them:

```rust
struct MyApp {
    tree_state: TreeState,      // App owns, can query/mutate
    table_state: TableState,    // App owns, can query/mutate
    selected_file: Option<usize>, // App-level selection tracking
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    // App can imperatively control semantic state
    if self.should_expand_path {
        self.tree_state.expand_path(&["root", "folder", "subfolder"]);
        self.should_expand_path = false;
    }

    // App can query state
    if self.tree_state.is_expanded("node-123") {
        // ...
    }

    vec![
        Layer::fill(panel("Files", |ui| {
            // Component mutates state during interaction
            ui.tree(&self.nodes, &mut self.tree_state)
                .on_select(Self::handle_select)
                .on_toggle(Self::handle_toggle);

            // App uses selection to drive other UI
            if let Some(selected) = self.tree_state.selected() {
                ui.text(format!("Selected: {}", selected));
            }
        }))
    ]
}
```

**State object APIs:**

```rust
// TreeState - expansion + selection
impl TreeState {
    pub fn new() -> Self;
    pub fn expand_path(&mut self, path: &[&str]);
    pub fn collapse_path(&mut self, path: &[&str]);
    pub fn is_expanded(&self, node_id: &str) -> bool;
    pub fn selected(&self) -> Option<String>;
    pub fn select(&mut self, node_id: String);
}

// TableState - sorting + column widths + selection
impl TableState {
    pub fn new() -> Self;
    pub fn sort_by(&mut self, col: usize, order: SortOrder);
    pub fn set_column_width(&mut self, col: usize, width: u16);
    pub fn selected(&self) -> Option<(usize, usize)>;
}

// ListState - selection (scroll is automatic)
impl ListState {
    pub fn new() -> Self;
    pub fn selected(&self) -> Option<usize>;
    pub fn select(&mut self, index: usize);
}
```

**Benefits:**
- ✅ Apps control semantic state when needed (search → expand path)
- ✅ Apps query state for conditional UI (show details if selected)
- ✅ Components still hide low-level details (cursor, scroll)
- ✅ Clear boundary: app-meaningful state is exposed, internal details hidden

### Multiple Components of Same Type

Apps with multiple lists/trees differentiate using separate callbacks:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Split View", |ui| {
            ui.list(&self.source_items)
                .on_activate(Self::handle_source_activate);

            ui.list(&self.target_items)
                .on_activate(Self::handle_target_activate);
        }))
    ]
}

fn handle_source_activate(&mut self, ctx: &mut Context, index: usize) {
    self.process_source_item(index);
}

fn handle_target_activate(&mut self, ctx: &mut Context, index: usize) {
    self.process_target_item(index);
}
```

**Each component has its own callbacks** - no confusion, no IDs needed.

### Keybind Integration

**Problem**: Components handle navigation keys (arrows, PageUp/Down) automatically. What about app keybinds?

**Solution**: Keybind priority system:

1. **Focused component** gets first chance at key
2. **Component refuses** → App keybinds checked
3. **App doesn't handle** → Global keybinds (Ctrl+Space, F1, etc.)

```rust
impl Runtime {
    fn handle_key(&mut self, key: KeyCode) {
        // 1. Give focused component first chance
        if let Some(focused) = self.focus.focused_component() {
            if focused.handle_key(key) {
                return;  // Component consumed the key
            }
        }

        // 2. Check app keybinds
        if let Some(action) = self.active_app.keybinds().get(key) {
            action.call(&mut self.active_app);
            return;
        }

        // 3. Check global keybinds
        if let Some(global) = self.global_keybinds.get(key) {
            global.call();
            return;
        }

        // 4. Ignore unhandled key
    }
}
```

**Components only consume navigation keys** - letter keys, Ctrl+keys, etc. pass through to app.

### Benefits

✅ **No on_render callbacks** - components know dimensions immediately
✅ **No message explosion** - callbacks instead of Msg enum variants
✅ **No state boilerplate** - components manage cursor/scroll internally
✅ **Automatic navigation** - components handle arrow keys, scroll wheel internally
✅ **Simple interactions are trivial** - `ui.button("Save").on_click(Self::handle_save)`
✅ **Consistent callback pattern** - all components use same approach
✅ **Type-safe** - compiler catches mismatched callback signatures
✅ **No boilerplate** - ~90% less code compared to V1

### Migration from V1

**V1 Button with message:**
```rust
// V1
Element::button(id, "Save")
    .on_press(Msg::Save)
    .build()

enum Msg {
    Save,
}

fn update(state: &mut State, msg: Msg) -> Command<Msg> {
    match msg {
        Msg::Save => {
            state.save();
            Command::None
        }
    }
}

// V2
ui.button("Save")
    .on_click(Self::handle_save);

fn handle_save(&mut self, ctx: &mut Context) {
    self.save();
}
```

**V1 List with multiple messages:**
```rust
// V1 (5 callbacks + 5 Msg variants + manual navigation)
Element::list(id, items, state)
    .on_select(Msg::ListSelect)
    .on_activate(Msg::ListActivate)
    .on_navigate(Msg::ListNavigate)
    .on_render(Msg::ListViewportHeight)
    .build()

enum Msg {
    ListSelect(usize),
    ListActivate(usize),
    ListNavigate(KeyCode),
    ListViewportHeight(usize),
}

fn update(state: &mut State, msg: Msg) -> Command<Msg> {
    match msg {
        Msg::ListNavigate(key) => {
            match key {
                KeyCode::Up => state.list.navigate_up(),
                KeyCode::Down => state.list.navigate_down(),
                // ...
            }
            Command::None
        }
        Msg::ListActivate(idx) => {
            state.open_item(idx);
            Command::None
        }
        // ...
    }
}

// V2 (1 callback, no messages, no manual navigation)
ui.list(&self.items)
    .on_activate(Self::handle_activate);

fn handle_activate(&mut self, ctx: &mut Context, index: usize) {
    self.open_item(index);
}
```

**V1 TextInput with manual state:**
```rust
// V1 (manual cursor/scroll tracking)
struct State {
    name: String,
    name_cursor: usize,
    name_scroll: usize,
}

Element::text_input(id, &state.name, &state.name_cursor)
    .on_event(Msg::NameInputEvent)
    .build()

Msg::NameInputEvent(event) => {
    // Manually update cursor, scroll, value
    state.handle_text_input_event(event);
    Command::None
}

// V2 (automatic cursor/scroll management)
struct MyApp {
    name: String,  // Just the value
}

ui.text_input(&mut self.name)
    .on_submit(Self::handle_submit);

fn handle_submit(&mut self, ctx: &mut Context) {
    self.submit_form();
}
```

---

## Layout System

### Layout Primitives

V2 provides four core layout primitives:

```rust
// Horizontal layout
ui.row(|ui| {
    ui.button("A");
    ui.button("B");
});

// Vertical layout
ui.col(|ui| {
    ui.text("Header");
    ui.button("Action");
});

// Panel with border and title
ui.panel("Settings", |ui| {
    ui.text("Content");
});

// Container with padding only (no border)
ui.container(|ui| {
    ui.text("Padded content");
});
```

**Omissions:**
- ❌ **stack** - Use layer system for overlays
- ❌ **grid** - Compose using row/col
- ❌ **scroll container** - Use Scrollable component instead

### Constraint System

Four constraint types for sizing:

```rust
pub enum Constraint {
    Length(u16),      // Exactly N chars/lines
    Percentage(u16),  // N% of parent space (0-100)
    Fill(u16),        // Proportional weight
    Min(u16),         // At least N chars/lines
}
```

**Usage:**
```rust
ui.row(|ui| {
    ui.button("Fixed").width(Length(20));
    ui.button("25%").width(Percentage(25));
    ui.button("Fill 2x").width(Fill(2));
    ui.button("Fill 1x").width(Fill(1));  // Gets half as much as Fill(2)
    ui.button("Min 10").width(Min(10));   // At least 10, grows if space available
});
```

### Auto-Constraints (Smart Defaults)

**Elements auto-size to content by default** - explicit constraints override:

```rust
// Auto-sizes to label + padding
ui.button("Save");

// Override to fill available space
ui.button("Save").width(Fill(1));

// Override to exact size
ui.button("Save").width(Length(30));
```

**Default behavior per element:**
- **Button**: `Length(label.len() + padding)`
- **Text**: `Length(text.len())`
- **TextInput**: `Fill(1)` (wants to expand)
- **List**: `Fill(1)` for both width and height
- **Panel**: Auto-size to content + 2 lines for border

### Nesting Behavior

**Parent is truth** - child cannot exceed parent's allocated space:

```rust
ui.col(|ui| {
    ui.row(|ui| {
        ui.button("Wide").width(Length(100));  // Requests 100 chars
    }).width(Length(50));  // Row only has 50 chars available

    // Button gets 50 chars, not 100 (parent clips)
});
```

**Constraint inheritance:**
- Children inherit parent's available space as their maximum
- Children can request less than parent's space
- Children **cannot** exceed parent's space
- Parent does NOT inherit child's constraints upward

### Alignment System

Alignment is **separate from constraints** - two orthogonal concerns:

#### 1. Manual Fill Spacers

Explicit flexible space for manual control:

```rust
ui.row(|ui| {
    ui.button("Left");
    ui.fill();  // Flexible spacer - pushes elements apart
    ui.button("Right");
});

// Center an element
ui.row(|ui| {
    ui.fill();
    ui.button("Center");
    ui.fill();
});
```

#### 2. Parent-Level Alignment

Align all children as a group:

```rust
ui.row()
    .justify(Justify::Center)       // Main axis (horizontal for row)
    .align(Align::Center)           // Cross axis (vertical for row)
    .children(|ui| {
        ui.button("A");
        ui.button("B");
    });
```

**Justify options** (main axis):
```rust
enum Justify {
    Start,         // Pack to start
    End,           // Pack to end
    Center,        // Pack to center
    SpaceBetween,  // First at start, last at end, equal gaps
    SpaceAround,   // Equal space around each element
    SpaceEvenly,   // Equal space between all elements (including edges)
}
```

**Align options** (cross axis):
```rust
enum Align {
    Start,    // Align to top (row) or left (col)
    End,      // Align to bottom (row) or right (col)
    Center,   // Center
    Stretch,  // Fill cross axis
}
```

#### 3. Child-Level Alignment (Override)

Individual child overrides parent alignment:

```rust
ui.row()
    .align(Align::Center)  // Default: center all children
    .children(|ui| {
        ui.button("Top").align_self(AlignSelf::Start);    // Override: top
        ui.button("Center");                               // Uses parent default
        ui.button("Bottom").align_self(AlignSelf::End);   // Override: bottom
    });
```

### Container Features

#### Panel

Border + title + content:

```rust
ui.panel("Settings", |ui| {
    ui.text("Content");
})
.width(Length(40))
.height(Length(20));

// Or auto-size to content + borders
ui.panel("Auto", |ui| {
    ui.text("Sized to fit");
});  // Height = content height + 2 (top/bottom border)
```

#### Container

Padding only, no border:

```rust
ui.container(|ui| {
    ui.text("Padded content");
})
.padding(1)      // All sides
.padding_x(2)    // Left/right
.padding_y(1);   // Top/bottom
```

### Layer Positioning

Layers use `LayerArea` for positioning (separate from internal layout):

```rust
enum LayerArea {
    Fill,                      // Use all available space
    Centered(u16, u16),        // Width, height - centered in screen
    Rect(Rect),                // Explicit position
    Anchor(Anchor, u16, u16),  // Anchor point + width/height
    DockTop(u16),              // Reserve N lines at top
    DockBottom(u16),           // Reserve N lines at bottom
    DockLeft(u16),             // Reserve N columns at left
    DockRight(u16),            // Reserve N columns at right
}

enum Anchor {
    TopLeft, TopCenter, TopRight,
    CenterLeft, Center, CenterRight,
    BottomLeft, BottomCenter, BottomRight,
}
```

**Usage:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(self.main_ui()),

        Layer::centered(60, 20, panel("Modal", |ui| {
            ui.text("Centered modal");
        })),

        Layer::dock_top(3, panel("Header", |ui| {
            ui.text("Fixed header");
        })),

        Layer::at_anchor(Anchor::BottomRight, 30, 10, panel("Info", |ui| {
            ui.text("Bottom-right panel");
        })),
    ]
}
```

### Macros: Binned

**Decision**: No layout macros in V2.

Closure-based API is clean enough in immediate mode:

```rust
// V1 macro style (removed)
col![
    text("Header"),
    row![
        button("A"),
        button("B"),
    ],
]

// V2 closure style (keep)
ui.col(|ui| {
    ui.text("Header");
    ui.row(|ui| {
        ui.button("A");
        ui.button("B");
    });
});
```

**Reasoning:**
- Closures already provide clean nesting
- No Msg enum = no need to reduce boilerplate
- Macros add complexity for minimal benefit
- IDE autocomplete works better with methods

---

### Theme System

V2 separates visual customization into two orthogonal concerns:

**Theme** = Color palette (what things look like)
**StyleConfig** = Visual behavior (how things are rendered)

These can be mixed independently - swap themes while keeping style, or vice versa.

#### Color System (OKLCH)

**Internal representation uses OKLCH** for perceptually uniform color manipulation:

```rust
#[derive(Clone, Copy)]
struct Color {
    l: f32,  // Lightness: 0.0 - 1.0
    c: f32,  // Chroma: 0.0 - 0.4 (practical max)
    h: f32,  // Hue: 0.0 - 360.0
}

impl Color {
    // Perceptually uniform brightness adjustment
    fn dim(&self, factor: f32) -> Self {
        Color {
            l: (self.l * factor).clamp(0.0, 1.0),
            c: self.c,
            h: self.h,
        }
    }

    // Fade toward background (with desaturation)
    fn fade(&self, background: &Color, alpha: f32) -> Self {
        Color {
            l: self.l * alpha + background.l * (1.0 - alpha),
            c: self.c * alpha,  // Desaturate when fading
            h: self.h,
        }
    }

    // Adjust saturation
    fn with_chroma(&self, c: f32) -> Self {
        Color { c: c.clamp(0.0, 0.4), ..*self }
    }

    // Convert to Ratatui RGB for rendering
    fn to_rgb(&self) -> RatatuiColor {
        let (r, g, b) = oklch_to_rgb(self.l, self.c, self.h);
        RatatuiColor::Rgb(r, g, b)
    }
}
```

**Benefits:**
- ✅ Perceptually uniform - 50% dimming looks like 50% to human eye
- ✅ Consistent saturation - colors at same chroma have equal vibrancy
- ✅ Easy manipulation - brightness/saturation/hue independent
- ✅ Better gradients - no weird hue shifts

#### Theme Structure (~26 Semantic Colors)

Colors named by **purpose**, not hierarchy:

```rust
pub struct Theme {
    // === INTERACTION STATES (what user is doing) ===
    pub focus: Color,         // Focused element border/highlight
    pub selection: Color,     // Selected item background
    pub selection_fg: Color,  // Selected item text (may differ from main)
    pub hover: Color,         // Hovered element (if focus_mode uses it)
    pub active: Color,        // Pressed/active state
    pub disabled: Color,      // Disabled elements

    // === SEMANTIC FEEDBACK (system communication) ===
    pub error: Color,         // Error messages, failures
    pub warning: Color,       // Warnings, cautions
    pub success: Color,       // Success confirmations
    pub info: Color,          // Informational messages

    // === CONTENT (text and links) ===
    pub text: Color,          // Primary readable text
    pub text_dim: Color,      // Secondary/less important text
    pub text_muted: Color,    // Hints, labels, placeholder text
    pub text_disabled: Color, // Disabled state text
    pub link: Color,          // Clickable links
    pub link_hover: Color,    // Hovered link (if different)

    // === STRUCTURE (UI framework) ===
    pub border: Color,        // Primary borders (panels, buttons)
    pub border_dim: Color,    // Secondary borders (subtle dividers)
    pub separator: Color,     // Explicit dividers/rules
    pub bg_base: Color,       // Main application background
    pub bg_surface: Color,    // Elevated surface (lists, inputs)
    pub bg_elevated: Color,   // Modals, floating panels
    pub bg_panel: Color,      // Panel backgrounds

    // === ACCENTS (user customization) ===
    pub accent_1: Color,      // Generic highlight 1
    pub accent_2: Color,      // Generic highlight 2
    pub accent_3: Color,      // Generic highlight 3
}
```

**Default variants:**
- **Mocha** - Dark theme (Catppuccin-inspired)
- **Latte** - Light theme (Catppuccin-inspired)

Users can create custom themes via settings app.

#### StyleConfig (Visual Behavior)

**Non-color customization:**

```rust
pub struct StyleConfig {
    // Border rendering
    pub borders: BorderStyle,

    // Selection indicators
    pub list_selection: SelectionStyle,
    pub tree_selection: SelectionStyle,

    // Focus indicators
    pub focus_indicator: FocusStyle,

    // Component-specific
    pub tree_expansion: TreeExpansionStyle,
    pub cursor_shape: CursorShape,
    pub scrollbar_style: ScrollbarStyle,
    pub spinner_style: SpinnerStyle,

    // Layout defaults
    pub panel_padding: u16,
    pub default_spacing: u16,

    // Behavior
    pub animations_enabled: bool,
}
```

**Border styles:**

```rust
pub enum BorderStyle {
    Default,      // ─│┌┐└┘├┤┬┴ (box drawing)
    Rounded,      // ─│╭╮╰╯├┤┬┴ (rounded corners)
    Double,       // ═║╔╗╚╝╠╣╦╩ (double lines)
    Thick,        // ━┃┏┓┗┛┣┫┳┻ (heavy lines)
    Ascii,        // -|++++++ (ASCII fallback)
    Custom {
        horizontal: char,       // ─
        vertical: char,         // │
        top_left: char,         // ┌
        top_right: char,        // ┐
        bottom_left: char,      // └
        bottom_right: char,     // ┘
        left_t: char,           // ├
        right_t: char,          // ┤
        top_t: char,            // ┬
        bottom_t: char,         // ┴
        cross: char,            // ┼
    },
}
```

**Selection indicators:**

```rust
pub enum SelectionStyle {
    Highlight,                    // Background color only
    Prefix { char: String },      // "▶ " or "• " prefix
    Both { char: String },        // Prefix + background
    Border,                       // Border around item
    Underline,                    // Underline selected
}
```

**Focus indicators:**

```rust
pub enum FocusStyle {
    Border,                       // Colored border (current)
    BorderThick,                  // Thicker/double border
    Background,                   // Background color change
    Underline,                    // Underline only
    Prefix { char: String },      // Prefix indicator
}
```

**Tree expansion indicators:**

```rust
pub enum TreeExpansionStyle {
    Arrows,        // ▶ / ▼
    PlusMinus,     // + / -
    Chevrons,      // » / ˅
    Custom { collapsed: String, expanded: String },
}
```

**Cursor shapes:**

```rust
pub enum CursorShape {
    Block,         // █
    Underline,     // _
    Bar,           // |
}
```

**Scrollbar styles:**

```rust
pub struct ScrollbarStyle {
    pub position: ScrollbarPosition,
    pub track_char: char,
    pub thumb_char: char,
    pub visible: ScrollbarVisibility,
}

pub enum ScrollbarPosition {
    Right,
    Left,
}

pub enum ScrollbarVisibility {
    Always,
    WhenScrolling,
    Never,
}
```

**Spinner styles:**

```rust
pub enum SpinnerStyle {
    Dots,          // ⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏
    Line,          // -\|/
    Arrow,         // ←↖↑↗→↘↓↙
    Custom { frames: Vec<String> },
}
```

#### Usage Examples

**Colors from theme:**

```rust
// Direct color access
let style = Style::default()
    .fg(theme.text)
    .bg(theme.selection);

// Color manipulation
let dimmed = theme.focus.dim(0.7);          // 70% brightness
let faded = theme.error.fade(&theme.bg_base, 0.3);  // 30% opacity

// Helper methods
theme.error_style();    // Style with error color
theme.success_style();  // Style with success color
```

**Visual behavior from style config:**

```rust
// Selection rendering
match ctx.style.list_selection {
    SelectionStyle::Prefix { char } => {
        text = format!("{} {}", char, text);
        style = style.bg(theme.selection);
    }
    SelectionStyle::Highlight => {
        style = style.bg(theme.selection);
    }
    SelectionStyle::Both { char } => {
        text = format!("{} {}", char, text);
        style = style.bg(theme.selection);
    }
    // ...
}

// Border rendering
let block = match ctx.style.borders {
    BorderStyle::Default => Block::default()
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.border)),
    BorderStyle::Rounded => Block::default()
        .borders(Borders::ALL)
        .border_set(symbols::border::ROUNDED)
        .border_style(Style::default().fg(theme.border)),
    BorderStyle::Ascii => Block::default()
        .borders(Borders::ALL)
        .border_set(symbols::border::PLAIN)
        .border_style(Style::default().fg(theme.border)),
    BorderStyle::Custom { horizontal, vertical, ... } => {
        // Custom rendering with specified characters
    }
};

// Focus rendering
match ctx.style.focus_indicator {
    FocusStyle::Border => {
        style = style.fg(theme.focus);
    }
    FocusStyle::Background => {
        style = style.bg(theme.focus).fg(theme.bg_base);
    }
    // ...
}
```

#### Persistence

**Stored in SQLite database:**
- `theme.active` = "mocha" / "latte" / custom name
- `theme.{name}.{color}` = OKLCH values (L, C, H as floats)
- `style.borders` = "default" / "rounded" / etc.
- `style.list_selection` = "highlight" / "prefix:▶ " / etc.

**Loading:**
```rust
RuntimeConfig::load_from_options().await  // From database
Theme::default()                          // Mocha defaults
StyleConfig::default()                    // Default visual behavior
```

#### Runtime Switching

**Settings app provides:**
- Theme selector dropdown
- Live color preview (grid of all colors)
- Per-color editor with OKLCH sliders
- Style config editor (dropdowns/toggles)
- Create/delete/edit themes
- Import/export themes

**Changes apply immediately** - no restart required.

#### File Structure

```
tui/state/
├── theme.rs          # Theme struct, Color type, OKLCH conversion
├── style.rs          # StyleConfig struct, visual behavior enums
├── config.rs         # RuntimeConfig (combines theme + style)
└── focus.rs          # FocusMode enum
```

#### Migration from V1

**Renamed colors:**
```rust
// V1 → V2
accent_primary    → focus
accent_secondary  → link
accent_tertiary   → accent_1
accent_error      → error
accent_warning    → warning
accent_success    → success
accent_info       → info
accent_muted      → text_muted
text_primary      → text
text_secondary    → text_dim
text_tertiary     → text_muted
border_primary    → border
border_secondary  → border_dim
border_tertiary   → separator
bg_base           → bg_base (same)
bg_surface        → bg_surface (same)
bg_elevated       → bg_elevated (same)
palette_1-4       → accent_1-3 (reduced from 4 to 3)
```

**New colors:**
- `selection` / `selection_fg` - Separate from focus
- `hover` - Explicit hover state
- `active` - Pressed/active state
- `disabled` / `text_disabled` - Disabled states
- `link_hover` - Hovered link state
- `bg_panel` - Panel-specific background

**New concept:**
- `StyleConfig` - All non-color customization

---

### Keybind System

V2 keybinds use the existing options system with three distinct categories, each with support for multiple aliases per action.

#### Three Binding Categories

**1. Navigation Bindings** (`keybind.global.nav.*`)
- Semantic navigation actions (up, down, activate, cancel, etc.)
- Sent directly to focused components as NavActions
- Components handle internally (no app code needed)
- User can add vim-style or custom aliases

**2. Global Bindings** (`keybind.global.*`)
- Runtime-level actions
- Help menu, app launcher, quit, etc.
- Checked after navigation but before app bindings

**3. App Bindings** (`keybind.{app}.*`)
- App-specific actions
- Create, delete, refresh, export, etc.
- Lowest priority in key handling

#### Navigation Actions

**NavAction enum for semantic component navigation:**

```rust
pub enum NavAction {
    Up,           // Move selection/cursor up
    Down,         // Move selection/cursor down
    Left,         // Move left (tree collapse, etc.)
    Right,        // Move right (tree expand, etc.)
    PageUp,       // Navigate by page
    PageDown,     // Navigate by page
    Home,         // Jump to start
    End,          // Jump to end
    Activate,     // Confirm/select (Enter, Space)
    Cancel,       // Close/back (Esc)
    Next,         // Next item/tab (Tab)
    Previous,     // Previous item/tab (Shift+Tab)
}

impl NavAction {
    fn from_option_key(key: &str) -> Option<Self> {
        match key {
            "global.nav.up" => Some(NavAction::Up),
            "global.nav.down" => Some(NavAction::Down),
            "global.nav.left" => Some(NavAction::Left),
            "global.nav.right" => Some(NavAction::Right),
            "global.nav.page_up" => Some(NavAction::PageUp),
            "global.nav.page_down" => Some(NavAction::PageDown),
            "global.nav.home" => Some(NavAction::Home),
            "global.nav.end" => Some(NavAction::End),
            "global.nav.activate" => Some(NavAction::Activate),
            "global.nav.cancel" => Some(NavAction::Cancel),
            "global.nav.next" => Some(NavAction::Next),
            "global.nav.previous" => Some(NavAction::Previous),
            _ => None,
        }
    }
}
```

#### Alias System

**Multiple keys can trigger the same action** using `.alias1`, `.alias2` suffix pattern:

```rust
// Registration (in keybinds.rs)
registry.register(
    OptionDefBuilder::new("keybind", "global.nav.up")
        .display_name("Navigate Up")
        .description("Move selection/cursor up in focused component")
        .keybind_type(KeyCode::Up)  // Primary binding
        .build()?
)?;

// Optional aliases (user can add via settings)
registry.register(
    OptionDefBuilder::new("keybind", "global.nav.up.alias1")
        .display_name("Navigate Up (Vim)")
        .keybind_type(KeyCode::Char('k'))
        .build()?
)?;
```

**In database:**
```
keybind.global.nav.up = "Up"           # Primary (default)
keybind.global.nav.up.alias1 = "k"     # Vim style
keybind.global.nav.up.alias2 = "w"     # Custom user binding
```

**All three keys trigger the same NavAction::Up** - non-destructive customization.

#### Keybind Registration

**Navigation bindings:**
```rust
pub fn register_navigation(registry: &OptionsRegistry) -> Result<()> {
    // Directional navigation
    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.up")
            .display_name("Navigate Up")
            .description("Move selection/cursor up")
            .keybind_type(KeyCode::Up)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.down")
            .display_name("Navigate Down")
            .description("Move selection/cursor down")
            .keybind_type(KeyCode::Down)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.left")
            .display_name("Navigate Left")
            .description("Move left (collapse tree nodes)")
            .keybind_type(KeyCode::Left)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.right")
            .display_name("Navigate Right")
            .description("Move right (expand tree nodes)")
            .keybind_type(KeyCode::Right)
            .build()?
    )?;

    // Page navigation
    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.page_up")
            .display_name("Page Up")
            .keybind_type(KeyCode::PageUp)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.page_down")
            .display_name("Page Down")
            .keybind_type(KeyCode::PageDown)
            .build()?
    )?;

    // Jump navigation
    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.home")
            .display_name("Jump to Start")
            .keybind_type(KeyCode::Home)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.end")
            .display_name("Jump to End")
            .keybind_type(KeyCode::End)
            .build()?
    )?;

    // Actions
    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.activate")
            .display_name("Activate")
            .description("Activate/confirm selected item")
            .keybind_type(KeyCode::Enter)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.cancel")
            .display_name("Cancel")
            .description("Close modal/go back")
            .keybind_type(KeyCode::Esc)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.next")
            .display_name("Next")
            .description("Next tab/item")
            .keybind_type(KeyCode::Tab)
            .build()?
    )?;

    registry.register(
        OptionDefBuilder::new("keybind", "global.nav.previous")
            .display_name("Previous")
            .description("Previous tab/item")
            .keybind_type(KeyCode::BackTab)
            .build()?
    )?;

    Ok(())
}
```

**Global and app bindings** - same as V1, but can also use aliases:
```rust
// Global bindings
registry.register(
    OptionDefBuilder::new("keybind", "global.help")
        .display_name("Help Menu")
        .keybind_type(KeyCode::F(1))
        .build()?
)?;

registry.register(
    OptionDefBuilder::new("keybind", "global.app_launcher")
        .display_name("App Launcher")
        .keybind_type(KeyBinding::ctrl(KeyCode::Char('a')))
        .build()?
)?;

// App bindings
registry.register(
    OptionDefBuilder::new("keybind", "migration_env.create")
        .display_name("Create Migration")
        .keybind_type(KeyCode::Char('n'))
        .build()?
)?;
```

#### Runtime Key Handling

**Priority order when key is pressed:**

```rust
impl Runtime {
    fn handle_key(&mut self, key_event: KeyEvent) {
        // 1. Check if key is bound to a navigation action
        if let Some((nav_key, nav_action)) = self.lookup_navigation(key_event) {
            if let Some(focused) = self.focused_component() {
                if focused.handle_nav(nav_action) {
                    return;  // Component consumed the navigation action
                }
            }
        }

        // 2. Check global keybinds
        if let Some(global_action) = self.lookup_global_keybind(key_event) {
            self.handle_global_action(global_action);
            return;
        }

        // 3. Check app keybinds
        if let Some(app_action) = self.active_app.lookup_keybind(key_event) {
            app_action.call(&mut self.active_app);
            return;
        }

        // 4. Ignored - key not bound to anything
    }

    /// Lookup which navigation action this key triggers (checks primary + all aliases)
    fn lookup_navigation(&self, key: KeyEvent) -> Option<(&str, NavAction)> {
        for nav_key in &["up", "down", "left", "right", "activate", "cancel",
                         "page_up", "page_down", "home", "end", "next", "previous"] {
            let base_key = format!("global.nav.{}", nav_key);

            // Check primary binding
            let primary_option_key = format!("keybind.{}", base_key);
            if let Ok(bound_str) = self.config.options.get_string(&primary_option_key) {
                if let Ok(bound_key) = KeyBinding::from_str(&bound_str) {
                    if bound_key.matches(&key) {
                        if let Some(action) = NavAction::from_option_key(&base_key) {
                            return Some((nav_key, action));
                        }
                    }
                }
            }

            // Check aliases (alias1, alias2, ..., alias10)
            for i in 1..=10 {
                let alias_option_key = format!("keybind.{}.alias{}", base_key, i);
                if let Ok(bound_str) = self.config.options.get_string(&alias_option_key) {
                    if let Ok(bound_key) = KeyBinding::from_str(&bound_str) {
                        if bound_key.matches(&key) {
                            if let Some(action) = NavAction::from_option_key(&base_key) {
                                return Some((nav_key, action));
                            }
                        }
                    }
                }
            }
        }
        None
    }
}
```

#### Component Navigation Handling

**Components handle NavActions internally** - apps never see navigation keys:

```rust
// Internal to framework - apps don't touch this
impl ListComponent {
    fn handle_nav(&mut self, action: NavAction) -> bool {
        match action {
            NavAction::Up => {
                self.state.navigate_up();
                true  // Consumed
            }
            NavAction::Down => {
                self.state.navigate_down();
                true  // Consumed
            }
            NavAction::PageUp => {
                self.state.navigate_page_up();
                true
            }
            NavAction::PageDown => {
                self.state.navigate_page_down();
                true
            }
            NavAction::Home => {
                self.state.jump_to_start();
                true
            }
            NavAction::End => {
                self.state.jump_to_end();
                true
            }
            NavAction::Activate => {
                // Emit semantic event to app
                self.emit(ListEvent::Activated(self.state.selected()));
                true
            }
            _ => false  // Doesn't handle this action
        }
    }
}

impl TreeComponent {
    fn handle_nav(&mut self, action: NavAction) -> bool {
        match action {
            NavAction::Left => {
                self.state.collapse_selected();
                true
            }
            NavAction::Right => {
                self.state.expand_selected();
                true
            }
            // ... other actions similar to List
            _ => false
        }
    }
}
```

**Apps only handle semantic callbacks:**
```rust
// App code - no raw keys!
ui.list(&self.items)
    .on_activate(Self::handle_activate);

fn handle_activate(&mut self, ctx: &mut Context, index: usize) {
    self.open_item(index);
}
```

#### Keybind Presets

**Settings app provides preset buttons** - applies multiple aliases at once:

```rust
/// Apply Vim navigation preset (non-destructive - adds aliases)
pub async fn apply_vim_preset(options: &Options) -> Result<()> {
    options.set("keybind.global.nav.up.alias1", "k").await?;
    options.set("keybind.global.nav.down.alias1", "j").await?;
    options.set("keybind.global.nav.left.alias1", "h").await?;
    options.set("keybind.global.nav.right.alias1", "l").await?;
    options.set("keybind.global.nav.page_up.alias1", "Ctrl+u").await?;
    options.set("keybind.global.nav.page_down.alias1", "Ctrl+d").await?;
    options.set("keybind.global.nav.home.alias1", "g").await?;
    options.set("keybind.global.nav.end.alias1", "G").await?;
    Ok(())
}

/// Remove Vim preset (delete aliases)
pub async fn remove_vim_preset(options: &Options) -> Result<()> {
    options.delete("keybind.global.nav.up.alias1").await?;
    options.delete("keybind.global.nav.down.alias1").await?;
    // ... delete all vim aliases
    Ok(())
}
```

**After applying Vim preset:**
- Arrow keys still work (primary bindings unchanged)
- Vim keys also work (added as aliases)
- User can further customize either

#### Conditional Keybinds

**Apps conditionally register keybinds based on state** (same as V1):

```rust
fn keybinds(&self, ctx: &Context) -> Vec<Keybind> {
    let mut keybinds = vec![];

    if !self.show_modal {
        // Main view keybinds
        keybinds.push(Keybind::new(
            ctx.config.get_keybind("my_app.create"),
            "Create new item",
            Self::handle_create
        ));
        keybinds.push(Keybind::new(
            ctx.config.get_keybind("my_app.delete"),
            "Delete item",
            Self::handle_delete
        ));
    } else {
        // Modal keybinds (or empty to disable all app keybinds in modal)
        keybinds.push(Keybind::new(
            ctx.config.get_keybind("global.nav.cancel"),
            "Close modal",
            Self::handle_close_modal
        ));
    }

    keybinds
}
```

**Pattern:** Return different keybind sets based on app state. Runtime calls `keybinds()` every frame.

#### Conflict Detection

**Check for key conflicts across all categories:**

```rust
pub fn find_conflicts(key: KeyBinding, registry: &OptionsRegistry) -> Vec<String> {
    let mut conflicts = vec![];

    // Check all registered keybinds (primary + aliases)
    for option_def in registry.list_namespace("keybind") {
        if let Ok(bound_str) = option_def.default.as_string() {
            if let Ok(bound_key) = KeyBinding::from_str(&bound_str) {
                if bound_key == key {
                    conflicts.push(option_def.key.clone());
                }
            }
        }
    }

    conflicts
}
```

**Settings UI warns about conflicts:**
```
⚠️ Warning: Key 'k' is bound to multiple actions:
  - keybind.global.nav.up.alias1 (Navigate Up)
  - keybind.entity_comparison.create_mapping (Create Mapping)

Navigation binding takes precedence when component is focused.
App binding only triggers when no component is focused.
```

#### Settings UI

**Per-action keybind editor:**
```
╭─ Navigate Up ─────────────────────────────────╮
│ Primary:  ↑                      [Edit]       │
│ Alias 1:  k                      [Remove]     │
│ Alias 2:  w                      [Remove]     │
│                                  [Add Alias]  │
├───────────────────────────────────────────────┤
│ Description: Move selection/cursor up in      │
│              focused component                │
╰───────────────────────────────────────────────╯

[Apply Vim Preset]  [Remove Vim Preset]  [Reset to Defaults]
```

**Keybind listing grouped by category:**
```
╭─ Global Navigation ───────────────────────────╮
│ Navigate Up       ↑, k, w                     │
│ Navigate Down     ↓, j                        │
│ Activate          Enter                       │
│ Cancel            Esc                         │
├─ Global Actions ──────────────────────────────┤
│ Help Menu         F1                          │
│ App Launcher      Ctrl+A                      │
│ Quit              Ctrl+Q                      │
├─ App: Entity Comparison ──────────────────────┤
│ Create Mapping    m                           │
│ Delete Mapping    d                           │
│ Refresh Metadata  F5                          │
│ Export to Excel   F10                         │
╰───────────────────────────────────────────────╯
```

#### Benefits

✅ **Component-agnostic navigation** - One keybind set works across all components
✅ **Vim mode support** - Non-destructive aliases preserve arrow keys
✅ **Unlimited aliases** - User can bind as many keys as they want per action
✅ **No app boilerplate** - Apps never handle navigation keys
✅ **Conflict detection** - Warns about overlapping bindings
✅ **User customizable** - Full editor with presets
✅ **Uses existing infrastructure** - Options system + suffix pattern

---

### App Launcher (TODO)

**Ctrl+Space** brings up launcher, needs design for:
- How to discover/list backgrounded apps
- Recent apps ordering
- Category grouping
- Search/filtering

#### Context-Aware Help (TODO)

**F1** shows help, needs design for:
- Auto-generate from `App::keybinds()`?
- Custom help content per app?
- Global vs app-specific keybinds
- Help modal rendering

### Container Features

- **Panel**: title, explicit width/height, auto-sizing (+2 lines for borders)
- **Container**: configurable padding
- **Stack**: multiple layers with alignment (Center, TopLeft, etc.) and dim_below option

### Alignment & Positioning

- **9 alignment options**: Center, TopLeft, TopCenter, TopRight, BottomLeft, BottomCenter, BottomRight, etc.
- **Dim below**: layer option to dim everything below it

### Constraints System

- **LayoutConstraint**: Length (fixed), Min (minimum), Fill (proportional)
- **Auto-constraints**: each element type has default_constraint() method
- **Macro shorthand**: `use_constraints!()` imports Fill, Length, Min for shorter syntax

### Events & Queue System

**Inter-app communication patterns** (distinct from UI component events):

- **Event Broadcasting**: Apps publish typed events that other apps can subscribe to
- **Message Queue**: Background apps maintain work queues that persist across foreground/background transitions
- **Event Persistence**: Which events should be queued when receiving app is backgrounded vs dropped?
- **Event Priorities**: Should some events interrupt foreground app or wait until next foreground?
- **Typed Channels**: How to ensure type-safe communication between apps without shared Msg enum?
- **Event Replay**: Should events be replayable for debugging/testing?
- **Queue Limits**: How to handle backpressure when queue grows too large?

**Examples to design:**
- OperationQueue app receiving "operations:add" events while in background
- File watcher publishing "file:changed" events to multiple subscribers
- Migration app publishing progress events to status bar
- Global notification system (toasts) receiving events from any app

---

## Open Questions / TODO

- [ ] Conditional keybinds (different keys when modal open)? - Addressed via keybinds() returning different sets per state
- [ ] Resource progress tracking (0-100%)?
- [ ] Error recovery patterns for async?

---

## Non-Goals

- **V1 Compatibility** - Clean slate, rewrite apps
- **Complex Animations** - Terminal UIs don't need smooth transitions
- **Web/GUI Support** - TUI only, don't over-abstract
- **Time-Travel Debug** - Nice to have but not priority

---

## Next Steps

1. Continue brainstorming edge cases
2. Prototype core abstractions (Context, Layer, Resource)
3. Build 1-2 example apps to validate API
4. Iterate on ergonomics
5. Implementation plan (separate from this doc)
