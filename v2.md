# TUI Framework V2 - Design Brainstorm

**Status**: Design phase - Not ready for implementation

## Core Philosophy

### Immediate Mode + Structured Concurrency

- Apps get `&mut self` during render - direct mutation, no message passing
- Async is first-class via Resource/tasks
- Event-driven rendering only (no FPS loop)
- Zero boilerplate for common patterns

### What We're Fixing from V1

1. **Message Explosion** - Every interaction needs a Msg enum variant
2. **Command Ceremony** - Side effects require wrapping in Command::Perform
3. **Navigation/Focus Boilerplate** - Manual event routing, on_render callbacks
4. **Multi-View Hacks** - Separate apps when they should share state
5. **Hardcoded Layers** - GlobalUI, AppModal, etc. baked into framework
6. **Viewport Dimension Hacks** - "20" fallback + on_render callback for real size
7. **Keybind Hell** - Hardcoded keys, no user configuration

---

## Architecture

### App Trait

```rust
trait App: 'static {
    // Called once on creation
    fn new(ctx: &AppContext) -> Self;

    // Called on every event or invalidation - returns UI + layers
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer>;

    // Optional: Define app-specific keybinds
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
    }

    // Optional lifecycle
    fn on_background(&mut self) {}
    fn on_foreground(&mut self) {}
}
```

**No separate `view()` method** - `update()` handles events AND returns UI.

### Context API

```rust
struct Context {
    // View routing (multi-view apps)
    router: Router,

    // Task spawning with auto-polling
    tasks: TaskManager,

    // Pub/sub with auto-routing
    pubsub: PubSub,

    // UI builder (immediate mode)
    ui: UiBuilder,
}
```

### Example: Simple App

```rust
struct QueueApp {
    list_state: ListState,
    items: Vec<QueueItem>,
}

impl App for QueueApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("clear", "Clear queue", default_key!("Ctrl+K"), Self::handle_clear)
            .action("execute", "Execute", default_key!("Enter"), Self::handle_execute)
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        vec![
            Layer::fill(panel("Queue", |ui| {
                ui.text(format!("{} items", self.items.len()));

                // List auto-handles arrow keys - no boilerplate!
                ui.list(&mut self.list_state, &self.items, |item, ui| {
                    ui.text(&item.name);
                });

                // Button calls handler when clicked
                ui.button("Clear").on_click(Self::handle_clear);
            }))
        ]
    }

    // Handlers as separate methods (can be async!)
    async fn handle_clear(&mut self, ctx: &mut Context) {
        self.items.clear();
    }

    async fn handle_execute(&mut self, ctx: &mut Context) {
        if let Some(idx) = self.list_state.selected() {
            self.execute_item(idx).await;
        }
    }
}
```

---

## Multi-View Apps

**Problem**: Deadlines has FileSelect â†’ Mapping â†’ Inspection as 3 separate apps when it should be 1 app with 3 views sharing state.

**Solution**: Router

```rust
struct DeadlinesApp {
    // Shared state across all views
    file: Option<PathBuf>,
    mappings: HashMap<String, String>,
    parsed_data: Resource<Vec<Deadline>>,

    // View-specific state
    file_browser: FileBrowserState,
    mapping_list: ListState,
    inspection_tree: TreeState,
}

impl App for DeadlinesApp {
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // Route to current view
        let ui = match ctx.router.current() {
            VIEW_FILE_SELECT => self.view_file_select(ctx),
            VIEW_MAPPING => self.view_mapping(ctx),
            VIEW_INSPECTION => self.view_inspection(ctx),
            _ => empty(),
        };

        vec![Layer::fill(ui)]
    }

    fn view_file_select(&mut self, ctx: &mut Context) -> Element {
        panel("Select File", |ui| {
            ui.file_browser(&mut self.file_browser);

            // Events returned inline - no closures!
            if let Some(Event::FileSelected(path)) = ui.events().file_browser() {
                self.file = Some(path.clone());

                // Start loading
                self.parsed_data.load(ctx, parse_excel(path));

                // Navigate to next view
                ctx.router.navigate(VIEW_MAPPING);
            }
        })
    }

    fn view_mapping(&mut self, ctx: &mut Context) -> Element {
        panel("Map Columns", |ui| {
            self.parsed_data.render(ui, |data, ui| {
                ui.list(&mut self.mapping_list, &self.mappings);

                if ui.button("Next").clicked() {
                    ctx.router.navigate(VIEW_INSPECTION);
                }
            });
        })
    }

    fn view_inspection(&mut self, ctx: &mut Context) -> Element {
        // Third view - same app, shared state!
        panel("Inspect", |ui| {
            self.parsed_data.render(ui, |data, ui| {
                ui.tree(&mut self.inspection_tree, data);
            });
        })
    }
}
```

---

## Pub/Sub (Auto-Managed)

**No manual polling** - framework calls handler methods automatically.

```rust
impl App for OperationQueue {
    fn new(ctx: &AppContext) -> Self {
        // Subscribe with handler method
        ctx.subscribe("operations:add", Self::on_operations_received);

        Self { queue: Vec::new() }
    }

    // Called automatically when message arrives (even in background!)
    fn on_operations_received(&mut self, msg: Message) {
        let ops: Vec<Operation> = msg.parse();
        self.queue.extend(ops);
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // No manual polling needed!
        vec![
            Layer::fill(panel("Queue", |ui| {
                ui.list(&mut self.queue_state, &self.queue);
            }))
        ]
    }
}

// Publishing from another app
fn some_handler(&mut self, ctx: &mut Context) {
    ctx.pubsub.publish("operations:add", &self.data);
}
```

**Framework handles all Arc/Mutex/RwLock internally.**

---

## Resource Pattern (Auto-Managed Async)

```rust
struct MyApp {
    data: Resource<Data>,
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Data", |ui| {
            if ui.button("Load").clicked() {
                // Framework handles spawning, polling, invalidation
                self.data.load(ctx, async {
                    fetch_data().await
                });
            }

            // Resource has built-in render method
            self.data.render(ui,
                || spinner(),           // Loading
                |data| text(data),      // Success
                |err| error(err),       // Failure
            );
        }))
    ]
}
```

`ctx.spawn_into()` handles Arc/Mutex, updates Resource when complete, auto-invalidates UI.

---

## Keybinds (First-Class)

### Declarative Definition

```rust
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("save", "Save changes", default_key!("Ctrl+S"), Self::handle_save)
            .action("quit", "Quit app", default_key!("q"), Self::handle_quit)
            .action("refresh", "Refresh data", default_key!("r"), Self::handle_refresh)
    }
}
```

### User Configuration

```toml
# ~/.config/dynamics/keybinds.toml
[global]
app_launcher = "Ctrl+Space"
help = "F1"
quit = "Ctrl+Q"

[app.EntityComparison]
save = "Ctrl+S"
refresh = "F5"
quit = "Escape"  # Override global for this app
```

### Automatic Widget Navigation

**Widgets handle their own keys automatically - zero boilerplate!**

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Queue", |ui| {
            // List gets arrow keys automatically!
            ui.list(&mut self.list_state, &self.items);

            // Tree gets arrows + Space automatically!
            ui.tree(&mut self.tree_state, &self.nodes);

            // Text input gets typing automatically!
            ui.text_input(&mut self.input);
        }))
    ]
}
```

**Framework routing (hidden from user):**

1. Check focused widget - does it want this key?
2. Not consumed? Check global keybinds (app_launcher, help, etc.)
3. Still not consumed? Check app keybinds
4. Not bound? Ignore

### Button Keybind Integration

```rust
// Button and keybind independently call same handler
ui.button("Clear All").on_click(Self::handle_clear);

// Framework can optionally show "Clear All (Ctrl+K)" by matching handler signatures
```

---

## Layer System (Simple Stack)

**No enum, no hardcoded types - just a stack with metadata.**

```rust
struct Layer {
    element: Element,
    area: LayerArea,
    dim_below: bool,
    blocks_input: bool,
}

enum LayerArea {
    Fill,                      // Use all available space
    Centered(u16, u16),        // Width, height
    Rect(Rect),                // Explicit position
    Anchor(Anchor, u16, u16),  // TopLeft, BottomRight, etc.
    DockTop(u16),              // Reserve N lines at top
    DockBottom(u16),
    DockLeft(u16),
    DockRight(u16),
}
```

### Multi-Layer Example

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        // Base UI
        Layer::fill(self.main_ui()),
    ];

    // Confirmation modal (if showing)
    if self.show_confirm {
        layers.push(
            Layer::centered(50, 15, panel("Confirm?", |ui| {
                ui.text("Are you sure?");
                ui.button("Yes").on_click(Self::handle_confirm);
                ui.button("No").on_click(Self::handle_cancel);
            }))
            .dim_below(true)
            .blocks_input(true)
        );
    }

    // Tooltip (always on top, doesn't block input)
    if let Some(tooltip) = &self.tooltip {
        layers.push(
            Layer::at(self.mouse_pos, text(tooltip))
        );
    }

    layers
}
```

### Global UI = Just Another Layer

Instead of hardcoded `GlobalUI`, runtime provides header/footer via system layers:

```rust
// Runtime automatically prepends/appends system layers
fn render(&mut self) {
    let mut all_layers = vec![];

    // System header (unless app opts out)
    if !app.layout_mode().is_fullscreen() {
        all_layers.push(
            Layer::dock_top(3, self.render_header())
        );
    }

    // Get app's layers
    all_layers.extend(self.active_app.update());

    // System help modal (if F1 pressed)
    if self.showing_help {
        all_layers.push(
            Layer::centered(80, 30, self.render_help())
                .dim_below(true)
                .blocks_input(true)
        );
    }

    self.renderer.render(&all_layers);
}
```

Apps can opt out:

```rust
impl App for FullscreenVideoPlayer {
    fn layout_mode() -> LayoutMode {
        LayoutMode::Fullscreen  // No header/footer
    }
}
```

---

## Widget Dimensions (No More Hacks!)

**V1 Problem**: Scrollable widgets need viewport dimensions, but we don't know until render. Solution was "20" fallback + `on_render` callback - 1-frame delay hack!

**V2 Solution**: Immediate mode - widgets get dimensions during render:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Records", |ui| {
            // ui.list() happens during render, already knows its size!
            ui.list(&mut self.list_state, &self.records);

            // No viewport_height param needed
            // No on_render callback
            // No hardcoded "20" fallback
        }))
    ]
}
```

---

## Focus System

### Automatic Focus Order (Zero Boilerplate)

Focus order follows **render order** - no explicit registration needed:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name);     // Focus index 0
            ui.text_input(&mut self.email);    // Focus index 1
            ui.button("Cancel");               // Focus index 2
            ui.button("Submit");               // Focus index 3
        }))
    ]
}
```

**Tab/Shift-Tab** cycles through indices: 0 â†’ 1 â†’ 2 â†’ 3 â†’ 0.

### Layer-Scoped Focus (Auto-Restoration)

Each layer maintains independent focus state:

```rust
Layer 0 (Base App):     focused_index = Some(2)  // "Submit" button
Layer 1 (Modal):        focused_index = Some(0)  // "Yes" button (receiving input)
```

When modal closes, Layer 0's focus is **automatically restored to index 2** - no manual tracking!

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(self.main_form(ctx))  // Has focus on "Submit"
    ];

    if self.show_confirm {
        layers.push(
            Layer::centered(40, 10, panel("Confirm?", |ui| {
                ui.button("Yes");  // Gets focus when modal opens
                ui.button("No");
            }))
        );
    }

    layers  // When confirm closes, "Submit" auto-focused again
}
```

### Programmatic Focus

Two approaches for different use cases:

#### 1. Declarative (Common Case)

Focus based on app state - evaluated during widget construction:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name)
                .auto_focus(self.name_invalid);  // Focus if validation failed

            ui.text_input(&mut self.email);

            ui.button("Submit")
                .auto_focus(self.just_loaded);  // Focus on first render
        }))
    ]
}
```

#### 2. Imperative (Rare Cases)

Programmatic focus by ID - applied after UI construction completes (same render cycle):

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Select File", |ui| {
            ui.file_browser(&mut self.browser);

            // User just selected file
            if let Some(Event::FileSelected(path)) = ui.events().file_browser() {
                self.handle_file_selected(path);
                ctx.focus.request("continue-button");  // Focus continue button
            }

            ui.button("Continue").id("continue-button");
        }))
    ]
}
```

**Focus requests are applied immediately** (in the same render cycle, after UI construction).

**Optional IDs** - only needed for programmatic focus. Most widgets don't need them.

### User Navigation Takes Precedence

**Problem**: What if auto-focus competes with user navigation?

```rust
// Frame 1: File selected, button auto-focused
ui.button("Continue").auto_focus(file_selected);  // âœ“ Focused

// Frame 2: User presses Shift+Tab to go back
// auto_focus(file_selected) is STILL true!
// Who wins? ðŸ¤”
```

**Solution**: User navigation events suppress auto-focus hints:

```rust
impl Runtime {
    fn handle_event_and_render(&mut self, event: Event) {
        // 1. Handle user navigation FIRST (before app update)
        let user_navigated = match event {
            Event::Key(KeyCode::Tab) => { self.focus.next(); true }
            Event::Key(KeyCode::BackTab) => { self.focus.prev(); true }
            Event::Mouse(click) => { self.focus.set_from_click(click); true }
            _ => false
        };

        // 2. Let app update and build UI
        let ctx = Context { user_navigated, ... };
        let layers = self.app.update(ctx);

        // 3. Apply auto-focus hints ONLY if user didn't navigate
        if !user_navigated {
            self.apply_auto_focus_hints();
        }

        // 4. Render
        self.render(layers);
    }
}
```

**Behavior**:
- File selected â†’ button auto-focused âœ“
- User presses Shift+Tab â†’ focus moves to previous element âœ“
- User can freely navigate, auto-focus doesn't fight back âœ“

### Progressive Unfocus (Esc Behavior)

```rust
impl Runtime {
    fn handle_escape(&mut self) {
        // 1. If something focused on top layer, blur it
        if self.focus.top_layer().has_focus() {
            self.focus.top_layer_mut().blur();
            return;
        }

        // 2. If multiple layers, close top layer (modal)
        if self.layers.len() > 1 {
            self.layers.pop();
            // Focus automatically restored to layer below!
            return;
        }

        // 3. Quit app
        self.quit();
    }
}
```

**Behavior**: Esc â†’ blur current â†’ close layer â†’ quit app

### Focus Modes (User Configurable)

```rust
enum FocusMode {
    Click,              // Focus only on click (default)
    Hover,              // Focus follows mouse
    HoverWhenUnfocused, // Hover only when nothing focused
}
```

**User config**:
```toml
# ~/.config/dynamics/config.toml
[ui]
focus_mode = "HoverWhenUnfocused"
```

**Runtime handles mouse moves based on mode**:

```rust
impl Runtime {
    fn handle_mouse_move(&mut self, x: u16, y: u16) {
        let element = self.hit_test(x, y);

        match self.config.focus_mode {
            FocusMode::Hover => {
                if let Some(idx) = element.focus_index {
                    self.focus.set_index(idx);
                }
            }
            FocusMode::HoverWhenUnfocused => {
                if !self.focus.has_focus() {
                    if let Some(idx) = element.focus_index {
                        self.focus.set_index(idx);
                    }
                }
            }
            FocusMode::Click => { /* no-op */ }
        }
    }
}
```

### Focus Context API

```rust
impl Context {
    pub fn focus(&mut self) -> &mut FocusManager;
}

struct FocusManager {
    current_layer: usize,
    layers: Vec<LayerFocusState>,
}

impl FocusManager {
    // Request focus by ID (applied after UI construction)
    pub fn request(&mut self, id: &str);

    // Request focus on first focusable (for view navigation)
    pub fn request_first(&mut self);

    // Request focus on last focusable
    pub fn request_last(&mut self);

    // Clear focus (blur current element)
    pub fn blur(&mut self);

    // Check if anything is focused
    pub fn has_focus(&self) -> bool;
}
```

### Implementation Details

Each layer maintains its own focus list:

```rust
struct LayerFocusState {
    focused_index: Option<usize>,
    focusables: Vec<FocusableInfo>,
    id_to_index: HashMap<String, usize>,
}

struct FocusableInfo {
    index: usize,
    id: Option<String>,        // Optional, only if widget has .id("foo")
    element_type: ElementType, // For debugging/help text
}
```

Widgets auto-register as they render:

```rust
impl UiBuilder {
    pub fn button(&mut self, label: &str) -> ButtonBuilder {
        let focus_idx = self.current_layer_focusables.len();
        let is_focused = self.current_focused == Some(focus_idx);

        self.current_layer_focusables.push(FocusableInfo {
            index: focus_idx,
            id: None,
            element_type: ElementType::Button,
        });

        ButtonBuilder { focus_idx, is_focused, ... }
    }
}
```

**Key insight**: Focus list IS the render list - precomputed automatically during UI construction.

---

## Mouse Support

### Hit Testing (1-Frame Delay)

**Problem**: During `update()`, we're building UI but don't know element positions yet (layout happens after).

**Solution**: Use **previous frame's rectangles** for hover detection:

```rust
struct MouseState {
    position: (u16, u16),
    left_button: ButtonState,
    right_button: ButtonState,
    middle_button: ButtonState,
    scroll_delta: i16,
    element_rects: HashMap<String, Rect>,  // From PREVIOUS frame
}

impl MouseState {
    fn is_over(&self, id: &str) -> bool {
        self.element_rects.get(id)
            .map(|rect| rect.contains(self.position))
            .unwrap_or(false)
    }
}
```

**Runtime flow**:
1. Mouse moves to (50, 10)
2. App calls `update()` â†’ builds UI
3. Widgets check `ctx.mouse.is_over("my-button")` using last frame's rect
4. Runtime renders and computes new positions
5. Runtime updates `element_rects` for next frame

**1-frame delay (16ms @ 60fps)** - imperceptible to users!

### Inline Event Handling

Widgets return events inline - no message passing:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Controls", |ui| {
            // Button handles click internally
            if ui.button("Save").clicked() {
                self.save();
            }

            // List returns events
            if let Some(Event::Activated(idx)) = ui.events().list() {
                self.open_file(idx);
            }
        }))
    ]
}
```

**Widgets internally**:
```rust
impl UiBuilder {
    pub fn button(&mut self, label: &str) -> ButtonBuilder {
        let is_hovered = self.ctx.mouse.is_over(&self.current_id);
        let is_clicked = is_hovered && self.ctx.mouse.clicked();

        ButtonBuilder {
            label,
            is_hovered,   // For visual feedback
            is_clicked,   // Returned by .clicked()
        }
    }
}
```

### Automatic Hover Styles

Widgets automatically apply hover styles using `is_over()`:

```rust
fn render_button(&self, label: &str, id: &str, mouse: &MouseState, theme: &Theme) -> Paragraph {
    let is_hovered = mouse.is_over(id);

    let style = if is_hovered {
        Style::default()
            .fg(theme.accent_primary)
            .bg(theme.bg_surface)
    } else {
        Style::default().fg(theme.text_primary)
    };

    Paragraph::new(label).style(style)
}
```

**No app code needed** - widgets handle hover styling internally.

### Automatic Scroll Wheel

Widgets handle scroll wheel automatically when focused:

```rust
impl ListWidget {
    fn handle_mouse(&mut self, mouse: &MouseState, is_focused: bool) {
        if is_focused && mouse.is_over(&self.id) {
            if let Some(delta) = mouse.scroll_delta() {
                self.state.scroll_by(delta);
            }
        }
    }
}
```

**Apps don't need to handle scroll** - it just works!

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            // Scroll wheel works automatically when list is focused
            ui.list(&mut self.list_state, &self.items);
        }))
    ]
}
```

### Double-Click vs Single-Click

Widgets differentiate automatically:

```rust
// List widget internally
struct ListState {
    last_click_time: Instant,
    last_click_index: Option<usize>,
}

impl ListState {
    fn handle_click(&mut self, index: usize) -> ListEvent {
        let now = Instant::now();
        let is_double = self.last_click_index == Some(index)
            && now.duration_since(self.last_click_time) < Duration::from_millis(500);

        self.last_click_time = now;
        self.last_click_index = Some(index);

        if is_double {
            ListEvent::Activated(index)  // Double-click
        } else {
            ListEvent::Selected(index)   // Single-click
        }
    }
}
```

**App usage**:
```rust
if let Some(Event::Selected(idx)) = ui.events().list() {
    self.selected = idx;  // Single-click selects
}

if let Some(Event::Activated(idx)) = ui.events().list() {
    self.open_file(idx);  // Double-click opens
}
```

### Right-Click / Context Menus

Widgets can emit right-click events:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(panel("Files", |ui| {
            ui.list(&mut self.list, &self.files);

            // Check for right-click
            if let Some(Event::RightClick(idx)) = ui.events().list() {
                self.show_context_menu = true;
                self.context_menu_target = idx;
                self.context_menu_pos = ctx.mouse.position();
            }
        }))
    ];

    // Context menu as overlay layer
    if self.show_context_menu {
        layers.push(
            Layer::at(self.context_menu_pos, panel("", |ui| {
                if ui.button("Open").clicked() {
                    self.open_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Delete").clicked() {
                    self.delete_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Rename").clicked() {
                    self.show_rename_dialog = true;
                    self.show_context_menu = false;
                }
            }))
        );
    }

    layers
}
```

**Helper for common pattern**:

```rust
struct ContextMenu {
    visible: bool,
    position: (u16, u16),
    items: Vec<ContextMenuItem>,
}

impl ContextMenu {
    fn show(&mut self, pos: (u16, u16)) {
        self.visible = true;
        self.position = pos;
    }

    fn render(&mut self, ctx: &mut Context) -> Option<Layer> {
        if !self.visible { return None; }

        Some(Layer::at(self.position, panel("", |ui| {
            for item in &self.items {
                if ui.button(&item.label).clicked() {
                    (item.handler)();
                    self.visible = false;
                }
            }
        })))
    }
}
```

### MouseState API

```rust
struct MouseState {
    position: (u16, u16),
    left_button: ButtonState,
    right_button: ButtonState,
    middle_button: ButtonState,
    scroll_delta: i16,
    element_rects: HashMap<String, Rect>,
}

enum ButtonState {
    Up,
    JustPressed,   // Went down this frame
    Held,          // Down for multiple frames
    JustReleased,  // Went up this frame
}

impl MouseState {
    // Position queries
    fn position(&self) -> (u16, u16);
    fn is_over(&self, id: &str) -> bool;

    // Button queries
    fn clicked(&self) -> bool;              // Left button just pressed
    fn right_clicked(&self) -> bool;        // Right button just pressed
    fn is_dragging(&self) -> bool;          // Left button held + moved

    // Double-click detection (internal tracking)
    fn double_clicked(&self) -> bool;

    // Scroll queries
    fn scroll_delta(&self) -> i16;          // Positive = up, negative = down
}
```

**Context API**:
```rust
impl Context {
    pub fn mouse(&self) -> &MouseState;
}

// Apps/widgets use it
fn update(&mut self, ctx: &mut Context) {
    if ctx.mouse().is_over("my-element") {
        // ...
    }
}
```

### Focus Integration

Clicking an element focuses it (configurable via FocusMode):

```rust
impl Runtime {
    fn handle_mouse_click(&mut self, x: u16, y: u16) {
        // Find element at position
        if let Some(element) = self.hit_test(x, y) {
            // Focus it (if focusable)
            if element.is_focusable {
                self.focus.set_index(element.focus_index);
            }

            // Trigger click event
            self.mouse_state.left_button = ButtonState::JustPressed;
            self.invalidate();  // Re-render
        }
    }
}
```

Focus modes already designed in Focus System section:
- **Click** - Focus only on click (default)
- **Hover** - Focus follows mouse
- **HoverWhenUnfocused** - Hover focus when nothing focused

### Terminal Mouse Capture

Enable via crossterm:
```rust
crossterm::execute!(
    stdout,
    crossterm::event::EnableMouseCapture
)?;
```

Mouse events arrive through crossterm event stream:
```rust
match crossterm::event::read()? {
    Event::Mouse(MouseEvent { kind, column, row, .. }) => {
        match kind {
            MouseEventKind::Down(MouseButton::Left) => { /* ... */ }
            MouseEventKind::Up(MouseButton::Left) => { /* ... */ }
            MouseEventKind::Moved => { /* ... */ }
            MouseEventKind::ScrollUp => { /* ... */ }
            MouseEventKind::ScrollDown => { /* ... */ }
            _ => {}
        }
    }
}
```

**Key insight**: Widgets handle most mouse behavior internally. Apps only handle semantic events (file selected, button clicked, etc.) - not raw mouse events.

---

## Event-Driven Rendering

**Framework only calls `update()` when:**
- User input event (keyboard, mouse)
- Resource finishes loading
- Pub/sub message received
- Timer fires
- Explicit invalidation (`ctx.invalidate()`)

**No continuous rendering loop!** Saves CPU, battery-friendly.

---

## Background Apps

Apps can continue processing while not visible:

```rust
impl App for OperationQueue {
    fn new(ctx: &AppContext) -> Self {
        // This app runs in background
        ctx.set_lifecycle(Lifecycle::AlwaysActive);

        ctx.subscribe("operations:add", Self::on_operations_received);

        Self { queue: Vec::new() }
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        // Process queue even when user is viewing other apps
        if self.current.is_none() && !self.queue.is_empty() {
            let op = self.queue.remove(0);
            self.current = Some(op.clone());
            self.progress.load(ctx, execute_operation(op));
        }

        vec![Layer::fill(self.render_queue_ui())]
    }
}
```

---

## Component System

### Terminology

**Unified "Component" naming** - no more "widget" vs "element" confusion:

- **`Component<Msg>`** - the UI tree enum (internal to framework)
- **`XxxState`** - persistent component state (ButtonState, ListState, etc.)
- **"Component"** in all documentation (not "widget" or "element")

**File structure:**
```
tui/
â”œâ”€â”€ component.rs              # Component enum
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ button.rs            # ButtonState
â”‚   â”œâ”€â”€ list.rs              # ListState
â”‚   â”œâ”€â”€ tree.rs              # TreeState
â”‚   â”œâ”€â”€ table.rs             # TableState
â”‚   â”œâ”€â”€ text_input.rs        # TextInputState
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ navigable.rs     # NavigableState (shared 2D navigation)
â”‚       â””â”€â”€ styling.rs       # Shared styling helpers
```

**Users never see "Component" directly:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            ui.list(&mut self.list_state, &self.items);  // Clean API
            ui.button("Save");
        }))
    ]
}
```

### NavigableState: Unified 2D Navigation

**Problem**: Current navigation is inconsistent:
- List/Tree: 1D vertical only
- Table: needs 2D (row + column)
- Scrollable: has horizontal but disconnected from navigation

**Solution**: Single `NavigableState` supporting both 1D and 2D navigation:

```rust
pub struct NavigableState {
    // Selection (None = nothing selected)
    selected_row: Option<usize>,
    selected_col: Option<usize>,  // None for 1D components

    // Scrolling (0-based offsets)
    scroll_row: usize,
    scroll_col: usize,

    // Scrolloff (vim-style, lines from edge before scrolling)
    scroll_off: usize,

    // Viewport dimensions (set by framework during render)
    viewport_rows: usize,
    viewport_cols: usize,
}

impl NavigableState {
    // 1D constructor (List, Tree, FileBrowser)
    pub fn new_1d() -> Self {
        Self {
            selected_row: None,
            selected_col: None,  // Always None for 1D
            scroll_row: 0,
            scroll_col: 0,
            scroll_off: 5,
            viewport_rows: 0,
            viewport_cols: 0,
        }
    }

    // 2D constructor (Table, Grid)
    pub fn new_2d() -> Self {
        Self {
            selected_row: None,
            selected_col: Some(0),  // Column matters for 2D
            scroll_row: 0,
            scroll_col: 0,
            scroll_off: 5,
            viewport_rows: 0,
            viewport_cols: 0,
        }
    }

    // === VERTICAL NAVIGATION ===

    pub fn navigate_up(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            if row > 0 {
                self.selected_row = Some(row - 1);
                self.adjust_scroll_vertical(row_count);
            }
        } else if row_count > 0 {
            self.selected_row = Some(0);  // Select first if nothing selected
        }
    }

    pub fn navigate_down(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            if row + 1 < row_count {
                self.selected_row = Some(row + 1);
                self.adjust_scroll_vertical(row_count);
            }
        } else if row_count > 0 {
            self.selected_row = Some(0);
        }
    }

    pub fn navigate_page_up(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            let jump = self.viewport_rows.saturating_sub(1);
            self.selected_row = Some(row.saturating_sub(jump));
            self.adjust_scroll_vertical(row_count);
        }
    }

    pub fn navigate_page_down(&mut self, row_count: usize) {
        if let Some(row) = self.selected_row {
            let jump = self.viewport_rows.saturating_sub(1);
            self.selected_row = Some((row + jump).min(row_count - 1));
            self.adjust_scroll_vertical(row_count);
        }
    }

    // === HORIZONTAL NAVIGATION ===

    pub fn navigate_left(&mut self, col_count: usize) {
        // Only works if selected_col is Some (2D mode)
        if let Some(col) = self.selected_col {
            if col > 0 {
                self.selected_col = Some(col - 1);
                self.adjust_scroll_horizontal(col_count);
            }
        }
    }

    pub fn navigate_right(&mut self, col_count: usize) {
        if let Some(col) = self.selected_col {
            if col + 1 < col_count {
                self.selected_col = Some(col + 1);
                self.adjust_scroll_horizontal(col_count);
            }
        }
    }

    pub fn navigate_home(&mut self) {
        // Home = start of current row (column 0)
        if self.selected_col.is_some() {
            self.selected_col = Some(0);
            self.scroll_col = 0;
        }
    }

    pub fn navigate_end(&mut self, col_count: usize) {
        // End = end of current row
        if self.selected_col.is_some() && col_count > 0 {
            self.selected_col = Some(col_count - 1);
            self.adjust_scroll_horizontal(col_count);
        }
    }

    // === SCROLLOFF ADJUSTMENT (VIM-STYLE) ===

    fn adjust_scroll_vertical(&mut self, total_rows: usize) {
        if let Some(row) = self.selected_row {
            if self.viewport_rows == 0 { return; }

            // Don't scroll if all rows fit
            if total_rows <= self.viewport_rows {
                self.scroll_row = 0;
                return;
            }

            // Scrolloff logic (keep selection N rows from edge)
            let min_scroll = row.saturating_sub(
                self.viewport_rows.saturating_sub(self.scroll_off + 1)
            );
            let max_scroll = row.saturating_sub(self.scroll_off);

            if self.scroll_row < min_scroll {
                self.scroll_row = min_scroll;
            } else if self.scroll_row > max_scroll {
                self.scroll_row = max_scroll;
            }

            // Clamp to valid range
            let max_offset = total_rows.saturating_sub(self.viewport_rows);
            self.scroll_row = self.scroll_row.min(max_offset);
        }
    }

    fn adjust_scroll_horizontal(&mut self, total_cols: usize) {
        if let Some(col) = self.selected_col {
            if self.viewport_cols == 0 { return; }

            // Same scrolloff logic, horizontal
            if total_cols <= self.viewport_cols {
                self.scroll_col = 0;
                return;
            }

            let min_scroll = col.saturating_sub(
                self.viewport_cols.saturating_sub(self.scroll_off + 1)
            );
            let max_scroll = col.saturating_sub(self.scroll_off);

            if self.scroll_col < min_scroll {
                self.scroll_col = min_scroll;
            } else if self.scroll_col > max_scroll {
                self.scroll_col = max_scroll;
            }

            let max_offset = total_cols.saturating_sub(self.viewport_cols);
            self.scroll_col = self.scroll_col.min(max_offset);
        }
    }

    // === ACCESSORS ===

    // For 1D components (List, Tree, FileBrowser)
    pub fn selected_index(&self) -> Option<usize> {
        self.selected_row
    }

    // For 2D components (Table, Grid)
    pub fn selected_cell(&self) -> Option<(usize, usize)> {
        match (self.selected_row, self.selected_col) {
            (Some(r), Some(c)) => Some((r, c)),
            _ => None
        }
    }

    pub fn scroll_offset(&self) -> (usize, usize) {
        (self.scroll_row, self.scroll_col)
    }

    // Framework sets this during render (knows viewport size)
    pub fn set_viewport_size(&mut self, rows: usize, cols: usize) {
        self.viewport_rows = rows;
        self.viewport_cols = cols;
    }
}
```

### Component State Composition

Components compose `NavigableState` for consistent behavior:

```rust
// List (1D - only vertical navigation)
pub struct ListState {
    nav: NavigableState,
    last_click: Option<(usize, Instant)>,  // For double-click detection
}

impl ListState {
    pub fn new() -> Self {
        Self {
            nav: NavigableState::new_1d(),  // selected_col = None
            last_click: None,
        }
    }

    // Delegate navigation to shared state
    pub fn navigate_up(&mut self, count: usize) {
        self.nav.navigate_up(count);
    }

    pub fn navigate_down(&mut self, count: usize) {
        self.nav.navigate_down(count);
    }

    pub fn selected(&self) -> Option<usize> {
        self.nav.selected_index()
    }

    pub fn scroll_offset(&self) -> usize {
        self.nav.scroll_offset().0  // Just vertical
    }

    // List-specific: double-click detection
    pub fn handle_click(&mut self, index: usize) -> ListEvent {
        let now = Instant::now();
        let is_double = self.last_click
            .filter(|(idx, time)| {
                *idx == index && now.duration_since(*time) < Duration::from_millis(500)
            })
            .is_some();

        self.last_click = Some((index, now));

        if is_double {
            ListEvent::Activated(index)
        } else {
            ListEvent::Selected(index)
        }
    }
}

// Table (2D - both vertical and horizontal navigation)
pub struct TableState {
    nav: NavigableState,
    rows: usize,
    cols: usize,
}

impl TableState {
    pub fn new(rows: usize, cols: usize) -> Self {
        Self {
            nav: NavigableState::new_2d(),  // selected_col = Some(0)
            rows,
            cols,
        }
    }

    // Full 2D navigation
    pub fn navigate_up(&mut self) {
        self.nav.navigate_up(self.rows);
    }

    pub fn navigate_down(&mut self) {
        self.nav.navigate_down(self.rows);
    }

    pub fn navigate_left(&mut self) {
        self.nav.navigate_left(self.cols);
    }

    pub fn navigate_right(&mut self) {
        self.nav.navigate_right(self.cols);
    }

    pub fn selected(&self) -> Option<(usize, usize)> {
        self.nav.selected_cell()
    }
}

// Tree (1D but with expansion state)
pub struct TreeState {
    nav: NavigableState,
    expanded: HashSet<String>,  // Tree-specific
    node_parents: HashMap<String, String>,
    visible_order: Vec<String>,
}

impl TreeState {
    pub fn new() -> Self {
        Self {
            nav: NavigableState::new_1d(),
            expanded: HashSet::new(),
            node_parents: HashMap::new(),
            visible_order: Vec::new(),
        }
    }

    // Delegate navigation
    pub fn navigate_up(&mut self) {
        self.nav.navigate_up(self.visible_order.len());
    }

    pub fn navigate_down(&mut self) {
        self.nav.navigate_down(self.visible_order.len());
    }

    // Tree-specific: expansion
    pub fn toggle(&mut self, id: &str) {
        if self.expanded.contains(id) {
            self.expanded.remove(id);
        } else {
            self.expanded.insert(id.to_string());
        }
    }
}
```

### Shared Styling Helpers

Consistent visual feedback across all focusable components:

```rust
// components/shared/styling.rs
pub fn apply_focus_style(base: Style, is_focused: bool, theme: &Theme) -> Style {
    if is_focused {
        base.fg(theme.accent_primary).bg(theme.bg_surface)
    } else {
        base
    }
}
```

**Note**: No separate hover styling. Hover is only used for:
- Click targeting (which component is under mouse)
- Tooltips (show on hover without focusing)
- FocusMode behavior (hover can trigger focus)

Visual feedback is focus-only - cleaner and less noisy.

### Benefits

âœ… **Consistent navigation** - List, Tree, Table, FileBrowser all use same logic
âœ… **Scrolloff works everywhere** - vim-style scrolling behavior unified
âœ… **2D support built-in** - Table gets full keyboard navigation
âœ… **Less duplication** - Navigation written once, tested once
âœ… **Easy to extend** - New navigable components just compose NavigableState

---

## Lifecycle & App Management

### Simplified Lifecycle Model

In V2's immediate mode architecture, lifecycle is dramatically simpler than V1:

**V1 problems:**
- Two policies (QuitPolicy + SuspendPolicy) for one event
- Dead code (LoadingScreen's `on_suspend` never called due to `AlwaysActive`)
- Unused features (QuittingRequested, QuitOnIdle, KillReason)
- Unclear semantics (what does "Sleep" mean?)

**V2 solution:** One policy, clear semantics.

### Lifecycle Policy

```rust
trait App: 'static {
    fn new(ctx: &AppContext) -> Self;
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer>;

    // Lifecycle policy (static)
    fn lifecycle() -> Lifecycle {
        Lifecycle::Destroy  // Default: destroy when navigating away
    }

    // Lifecycle hooks (sync only)
    fn can_quit(&self) -> Result<(), String> { Ok(()) }
    fn quit_requested(&mut self) { }  // Called when vetoed, now foreground
    fn on_background(&mut self) { }   // Moved to background
    fn on_foreground(&mut self) { }   // Returned to foreground
    fn on_destroy(&mut self) { }      // About to be destroyed
}

enum Lifecycle {
    /// Destroy immediately when navigating away
    Destroy,

    /// Keep in background - still receive events and call update()
    /// (pub/sub, timers, async completions - but NOT keyboard/mouse)
    Background,
}
```

### When update() Is Called

**Foreground app:**
```rust
// update() called on:
- User input (keyboard, mouse)       âœ“
- Pub/sub messages                   âœ“
- Timers                             âœ“
- Async task completion              âœ“
```

**Background app:**
```rust
// update() called on:
- User input (keyboard, mouse)       âœ— (no longer foreground)
- Pub/sub messages                   âœ“
- Timers                             âœ“
- Async task completion              âœ“
```

### Runtime Navigation Behavior

```rust
impl Runtime {
    fn navigate_to(&mut self, target_app: AppId) {
        let current = self.active_app;

        // Handle current app based on its lifecycle policy
        match current.lifecycle() {
            Lifecycle::Destroy => {
                current.on_destroy();
                self.apps.remove(current);  // Destroyed
            }
            Lifecycle::Background => {
                current.on_background();
                self.background_apps.insert(current);  // Keep alive
            }
        }

        // Switch to target
        if self.background_apps.contains(target) {
            target.on_foreground();  // Resuming from background
        } else {
            // Create new instance
            target = Target::new(ctx);
        }

        self.active_app = target;
    }
}
```

### Global Quit Coordination

Runtime checks all apps (foreground + background) before quitting:

```rust
impl Runtime {
    fn handle_global_quit(&mut self) {
        // 1. Check foreground app first
        if let Err(reason) = self.active_app.can_quit() {
            self.active_app.quit_requested();
            return;  // Let app show its modal
        }

        // 2. Check all background apps
        for (app_id, app) in &self.background_apps {
            if let Err(reason) = app.can_quit() {
                // Navigate to this app
                self.navigate_to(app_id);
                // Notify it
                app.quit_requested();
                return;  // Let app show its modal
            }
        }

        // 3. All apps OK - call on_destroy on all, then quit
        for app in &mut self.apps {
            app.on_destroy();
        }

        // Give tokio 1 second for Drop impls to cleanup
        tokio::time::timeout(Duration::from_secs(1), async {
            // Let async tasks finish cleanup
        }).await;

        std::process::exit(0);
    }
}
```

**Example: OperationQueue blocks quit**

```rust
impl App for OperationQueue {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background  // Run in background
    }

    fn can_quit(&self) -> Result<(), String> {
        if !self.currently_running.is_empty() {
            Err(format!("{} operations in progress", self.currently_running.len()))
        } else {
            Ok(())
        }
    }

    fn quit_requested(&mut self) {
        // Runtime just brought us to foreground - show modal
        self.show_quit_confirm = true;
    }

    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        let mut layers = vec![/* main UI */];

        if self.show_quit_confirm {
            layers.push(
                ConfirmationModal::new(
                    "Quit Application?",
                    format!("{} operations running. Cancel and quit?", self.currently_running.len())
                )
                .on_yes(Self::handle_force_quit)
                .on_no(Self::handle_cancel_quit)
                .build()
            );
        }

        layers
    }

    fn handle_force_quit(&mut self, ctx: &mut Context) {
        // Cancel operations
        for id in &self.currently_running {
            self.mark_cancelled_sync(id);
        }
        ctx.quit();
    }

    fn handle_cancel_quit(&mut self) {
        self.show_quit_confirm = false;
        // User stays in queue, can monitor operations
    }

    fn on_destroy(&mut self) {
        // Quick sync cleanup - mark operations as cancelled in DB
        for id in &self.currently_running {
            self.mark_cancelled_sync(id);
        }
        // Tokio tasks dropped when app drops
        // Runtime gives them 1 second to finish cleanup
    }
}
```

**User experience:**

```rust
// Scenario: User presses Ctrl+Q while queue in background
// 1. Runtime checks foreground app â†’ OK
// 2. Runtime checks OperationQueue â†’ VETO ("3 operations running")
// 3. Runtime navigates to OperationQueue
// 4. Runtime calls queue.quit_requested()
// 5. Queue shows modal: "3 operations running. Cancel and quit?"
// 6. User sees which operations, can choose
```

### Memory Pressure Management

Runtime automatically cleans up old background apps:

```rust
impl Runtime {
    const MAX_BACKGROUND_APPS: usize = 10;

    fn check_memory_pressure(&mut self) {
        if self.background_apps.len() > Self::MAX_BACKGROUND_APPS {
            // Find oldest background app (least recently active)
            let oldest = self.background_apps
                .iter()
                .min_by_key(|app| app.last_active_time)
                .unwrap();

            log::info!("Memory pressure - destroying oldest background app: {:?}", oldest.id);

            // Give app chance to cleanup
            oldest.on_destroy();

            // Remove from runtime
            self.background_apps.remove(oldest.id);
        }
    }
}
```

**Apps don't specify cleanup timers** - that's runtime policy, not app policy.

### Hook Details

#### can_quit() - Veto Quit Attempts

```rust
fn can_quit(&self) -> Result<(), String> {
    if self.has_unsaved_changes {
        Err("You have unsaved changes".to_string())
    } else {
        Ok(())
    }
}
```

- Called by runtime when user tries to quit
- Check foreground app first, then background apps
- First app to veto is brought to foreground

#### quit_requested() - Handle Veto

```rust
fn quit_requested(&mut self) {
    // Runtime just brought us to foreground
    self.show_quit_confirm = true;  // Show modal
}
```

- Only called if `can_quit()` returned `Err`
- App is now foreground (runtime navigated to it)
- App shows modal explaining why it can't quit
- App provides options (force quit, wait, cancel)

#### on_background() - Moved to Background

```rust
fn on_background(&mut self) {
    // Clear state that shouldn't persist in background
    self.countdown_ticks = None;
    self.show_temporary_modal = false;
}
```

- Called when user navigates away from this app
- Only called if `lifecycle() == Background`
- App still receives pub/sub, timers, async completions
- App can still call `ctx.navigate()` to come back to foreground

#### on_foreground() - Returned to Foreground

```rust
fn on_foreground(&mut self) {
    // Refresh data if stale
    if self.last_refresh.elapsed() > Duration::from_secs(60) {
        self.refresh();
    }
}
```

- Called when user navigates back to this app
- Only called if app was in background (not freshly created)
- App should refresh any stale data

#### on_destroy() - About to Be Destroyed

```rust
fn on_destroy(&mut self) {
    // Quick sync cleanup only
    self.flush_buffers_sync();
    self.save_state_sync();
    // Drop impl handles async cleanup
}
```

- Called before app is removed from runtime
- **Sync only** - no async allowed
- Runtime gives 1 second grace period for Drop impls
- Use for quick cleanup (DB writes, buffer flushes)
- Tokio tasks are automatically dropped

### Why Hooks Are Sync

**Problem with async hooks:**
```rust
async fn on_destroy(&mut self) {
    self.log_buffer.flush().await;  // Blocks runtime!
    // UI frozen, user can't cancel, no progress feedback
}
```

**Solution: Sync hooks + grace period**
```rust
fn on_destroy(&mut self) {
    self.log_buffer.flush_sync();  // Quick sync flush
    // Or: mark for cleanup, Drop impl handles rest
}

impl Drop for MyApp {
    fn drop(&mut self) {
        // Async cleanup via Drop
        // Runtime gives 1 second grace period
    }
}
```

**Benefits:**
- âœ… UI stays responsive
- âœ… User can see progress via modals
- âœ… Apps control cleanup UX
- âœ… Runtime provides grace period for Drop

### Migration from V1

**V1 â†’ V2 equivalents:**

```rust
// v1: QuitPolicy::Sleep + SuspendPolicy::AlwaysActive
impl App for OperationQueue {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background
    }
    // No on_background needed - just keep running
}

// v1: QuitPolicy::Sleep + SuspendPolicy::Suspend + on_suspend
impl App for LoadingScreen {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Background
    }

    fn on_background(&mut self) {
        // Clear countdown to prevent stale navigation
        self.countdown_ticks = None;
        self.target_app = None;
    }
}

// v1: QuitPolicy::QuitOnExit or SuspendPolicy::QuitOnSuspend
impl App for ErrorScreen {
    fn lifecycle() -> Lifecycle {
        Lifecycle::Destroy  // Default
    }
}
```

### Benefits

âœ… **Simpler mental model** - One policy (Destroy or Background)
âœ… **No dead code** - LoadingScreen scenario works correctly
âœ… **Clearer semantics** - "Destroy or keep in background" is obvious
âœ… **Background apps block quit** - Queue can veto quit even when not foreground
âœ… **Memory managed by runtime** - Apps don't think about cleanup timers
âœ… **Sync hooks** - UI stays responsive, apps show progress modals

---

## Modal System

### Modals Are Just Layers

**Core concept:** Modals are not a special framework type - they're just layers with specific properties:

```rust
struct Layer {
    element: Component,
    area: LayerArea,
    dim_below: bool,      // Modals set this to true
    blocks_input: bool,   // Modals set this to true
}
```

**Creating a modal:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(self.main_ui())
    ];

    // Modal is just another layer
    if self.show_confirm {
        layers.push(
            Layer::centered(50, 15, panel("Confirm?", |ui| {
                ui.text("Are you sure?");
                ui.button("Yes").on_click(Self::handle_yes);
                ui.button("No").on_click(Self::handle_no);
            }))
            .dim_below(true)      // Dims everything below this layer
            .blocks_input(true)   // Prevents interaction with lower layers
        );
    }

    layers
}
```

**Apps control visibility** - framework doesn't auto-show/hide modals:

```rust
struct MyApp {
    show_confirm: bool,  // App owns this flag
    // ...
}

fn handle_delete(&mut self, ctx: &mut Context) {
    self.show_confirm = true;  // Show modal
}

fn handle_yes(&mut self, ctx: &mut Context) {
    self.delete_file();
    self.show_confirm = false;  // Hide modal
}

fn handle_no(&mut self, ctx: &mut Context) {
    self.show_confirm = false;  // Hide modal
}
```

### Hybrid Approach: Pattern + Optional Helpers

**Modals are a pattern, not a framework concept.**

Apps can choose:
1. **Raw layers** - maximum flexibility for custom modals
2. **Builder helpers** - convenience for common patterns

**File structure:**
```
tui/
â”œâ”€â”€ layer.rs                  # Layer type (core primitive)
â””â”€â”€ modals/                   # Optional builder helpers
    â”œâ”€â”€ mod.rs
    â”œâ”€â”€ confirmation.rs       # ConfirmationModal builder
    â”œâ”€â”€ error.rs              # ErrorModal builder
    â”œâ”€â”€ loading.rs            # LoadingModal builder (with spinner)
    â””â”€â”€ help.rs               # HelpModal (keybinding viewer)
```

### Raw Layers (Maximum Flexibility)

For custom modals, just use layers directly:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![Layer::fill(self.main_ui())];

    // Custom modal - full control over layout
    if self.show_settings {
        layers.push(
            Layer::centered(80, 30, panel("Settings", |ui| {
                ui.text("Theme:");
                ui.select(&mut self.theme_select, &["Mocha", "Latte"]);

                ui.text("");
                ui.text("Focus Mode:");
                ui.select(&mut self.focus_mode_select, &["Click", "Hover"]);

                ui.text("");
                if ui.button("Save").clicked() {
                    self.save_settings();
                    self.show_settings = false;
                }
                if ui.button("Cancel").clicked() {
                    self.show_settings = false;
                }
            }))
            .dim_below(true)
            .blocks_input(true)
        );
    }

    layers
}
```

### Builder Helpers (Convenience)

For common patterns, use builder types:

```rust
// tui/modals/confirmation.rs
pub struct ConfirmationModal {
    title: String,
    message: String,
    on_yes: Option<fn()>,
    on_no: Option<fn()>,
    on_cancel: Option<fn()>,  // Called on Esc
    width: u16,
    height: u16,
}

impl ConfirmationModal {
    pub fn new(title: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            title: title.into(),
            message: message.into(),
            on_yes: None,
            on_no: None,
            on_cancel: None,
            width: 50,
            height: 15,
        }
    }

    pub fn on_yes(mut self, handler: fn()) -> Self {
        self.on_yes = Some(handler);
        self
    }

    pub fn on_no(mut self, handler: fn()) -> Self {
        self.on_no = Some(handler);
        self
    }

    pub fn on_cancel(mut self, handler: fn()) -> Self {
        self.on_cancel = Some(handler);
        self
    }

    pub fn width(mut self, width: u16) -> Self {
        self.width = width;
        self
    }

    pub fn build(self) -> Layer {
        Layer::centered(self.width, self.height, panel(&self.title, |ui| {
            ui.text(&self.message);
            ui.text("");

            if let Some(yes) = self.on_yes {
                if ui.button("Yes").clicked() {
                    yes();
                }
            }

            if let Some(no) = self.on_no {
                if ui.button("No").clicked() {
                    no();
                }
            }
        }))
        .dim_below(true)
        .blocks_input(true)
        .on_escape(self.on_cancel)  // Register Esc handler
    }
}
```

**App usage:**
```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![Layer::fill(self.main_ui())];

    if self.show_delete_confirm {
        layers.push(
            ConfirmationModal::new("Delete File?", "This cannot be undone")
                .on_yes(Self::handle_confirm_delete)
                .on_no(Self::handle_cancel_delete)
                .on_cancel(Self::handle_cancel_delete)  // Esc = same as No
                .width(60)
                .build()
        );
    }

    layers
}

fn handle_confirm_delete(&mut self, ctx: &mut Context) {
    self.delete_file();
    self.show_delete_confirm = false;
}

fn handle_cancel_delete(&mut self, ctx: &mut Context) {
    self.show_delete_confirm = false;
}
```

### Built-in Modal Helpers

Framework provides builders for common patterns:

#### ConfirmationModal

Yes/No dialogs:

```rust
ConfirmationModal::new("Delete?", "This cannot be undone")
    .on_yes(Self::handle_yes)
    .on_no(Self::handle_no)
    .on_cancel(Self::handle_no)
    .build()
```

#### ErrorModal

Error display with dismiss button:

```rust
ErrorModal::new("Failed to Save", &error_message)
    .on_dismiss(Self::handle_error_dismiss)
    .build()
```

#### LoadingModal

Loading spinner with optional progress:

```rust
// Simple spinner
LoadingModal::new("Loading...")
    .build()

// With progress
LoadingModal::new("Processing files...")
    .progress(self.completed, self.total)
    .build()
```

#### HelpModal

Keybinding viewer (auto-populated from app keybinds):

```rust
HelpModal::new()
    .app_keybinds(MyApp::keybinds())
    .build()
```

### Modal Dismissal (Esc Behavior)

**Apps control when modals close** - framework doesn't auto-dismiss.

**Progressive Unfocus revised:**
```rust
impl Runtime {
    fn handle_escape(&mut self) {
        // 1. If something focused on top layer, blur it
        if self.focus.has_focus() {
            self.focus.blur();
            return;
        }

        // 2. If unfocused, dispatch to app via keybinds
        // Apps can:
        // - Close modals (via on_cancel handler)
        // - Quit app
        // - Do nothing
        self.dispatch_keybind("escape");
    }
}
```

**Modal builders register Esc handler:**
```rust
layers.push(
    ConfirmationModal::new("Delete?", "Sure?")
        .on_cancel(Self::handle_cancel)  // Called when Esc pressed
        .build()
);

fn handle_cancel(&mut self, ctx: &mut Context) {
    self.show_confirm = false;  // App controls dismissal
    self.cleanup_modal_state();
}
```

**Apps can also handle Esc globally:**
```rust
impl App for MyApp {
    fn keybinds() -> KeybindMap {
        KeybindMap::new()
            .action("close", "Close modal/quit", default_key!("Esc"), Self::handle_escape)
    }
}

fn handle_escape(&mut self, ctx: &mut Context) {
    if self.show_any_modal {
        // Close modal
        self.show_confirm = false;
        self.show_error = false;
        // ...
    } else {
        // Quit app
        ctx.quit();
    }
}
```

### Context Menu Pattern

Right-click context menus are just layers positioned at mouse:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let mut layers = vec![
        Layer::fill(panel("Files", |ui| {
            ui.list(&mut self.list, &self.files);

            if let Some(Event::RightClick(idx)) = ui.events().list() {
                self.show_context_menu = true;
                self.context_menu_target = idx;
                self.context_menu_pos = ctx.mouse.position();
            }
        }))
    ];

    // Context menu as overlay layer
    if self.show_context_menu {
        layers.push(
            Layer::at(self.context_menu_pos, panel("", |ui| {
                if ui.button("Open").clicked() {
                    self.open_file(self.context_menu_target);
                    self.show_context_menu = false;
                }
                if ui.button("Delete").clicked() {
                    self.show_delete_confirm = true;
                    self.show_context_menu = false;
                }
                if ui.button("Rename").clicked() {
                    self.show_rename_dialog = true;
                    self.show_context_menu = false;
                }
            }))
            .dim_below(false)     // Context menus don't dim
            .blocks_input(true)   // But they do block clicks
        );
    }

    layers
}
```

**Optional helper:**
```rust
// tui/modals/context_menu.rs
pub struct ContextMenu {
    items: Vec<(&'static str, fn())>,
    position: (u16, u16),
}

impl ContextMenu {
    pub fn new(position: (u16, u16)) -> Self {
        Self { items: vec![], position }
    }

    pub fn item(mut self, label: &'static str, handler: fn()) -> Self {
        self.items.push((label, handler));
        self
    }

    pub fn build(self) -> Layer {
        Layer::at(self.position, panel("", |ui| {
            for (label, handler) in &self.items {
                if ui.button(label).clicked() {
                    handler();
                }
            }
        }))
        .dim_below(false)
        .blocks_input(true)
    }
}

// Usage
layers.push(
    ContextMenu::new(self.context_menu_pos)
        .item("Open", Self::handle_open)
        .item("Delete", Self::handle_delete)
        .item("Rename", Self::handle_rename)
        .build()
);
```

### Benefits

âœ… **Simple mental model** - modals are just layers with flags
âœ… **Maximum flexibility** - raw layers available for custom modals
âœ… **Convenience helpers** - builders for common patterns (confirm, error, loading)
âœ… **App-controlled** - apps decide when to show/hide modals
âœ… **Consistent UI** - builders provide standard styling (but customizable)
âœ… **Easy to extend** - adding new modal types is just adding a builder

---

## Color System (OKLCH)

**Why OKLCH over RGB/HSL:**
- **Perceptually uniform** - 50% dimming looks like 50% to human eye (HSL doesn't)
- **Consistent saturation** - Red and blue at same chroma look equally vibrant (HSL fails)
- **Better gradients** - No weird hue shifts when interpolating
- **Easy manipulation** - Brightness, saturation, hue are independent

**Implementation:**

```rust
#[derive(Clone, Copy)]
struct Color {
    l: f32,  // Lightness: 0.0 - 1.0
    c: f32,  // Chroma: 0.0 - 0.4 (practical max)
    h: f32,  // Hue: 0.0 - 360.0
}

impl Color {
    // Easy brightness manipulation
    fn dim(&self, factor: f32) -> Self {
        Color {
            l: (self.l * factor).clamp(0.0, 1.0),
            c: self.c,
            h: self.h,
        }
    }

    // Fade toward background
    fn fade(&self, background: &Color, alpha: f32) -> Self {
        Color {
            l: self.l * alpha + background.l * (1.0 - alpha),
            c: self.c * alpha,  // Desaturate when fading
            h: self.h,
        }
    }

    // Saturate/desaturate
    fn with_chroma(&self, c: f32) -> Self {
        Color { c: c.clamp(0.0, 0.4), ..*self }
    }

    // Convert to Ratatui RGB for rendering
    fn to_rgb(&self) -> RatatuiColor {
        let (r, g, b) = oklch_to_rgb(self.l, self.c, self.h);
        RatatuiColor::Rgb(r, g, b)
    }
}

// Theme becomes OKLCH-based
struct Theme {
    bg_base: Color,      // L=0.2, C=0.02, H=240
    text_primary: Color, // L=0.9, C=0.02, H=240
    accent: Color,       // L=0.7, C=0.15, H=200
    // ...
}

impl Theme {
    // Easy to generate variations
    fn dim_overlay(&self) -> Color {
        self.bg_base.dim(0.5)  // Perceptually 50% darker
    }

    fn hover_accent(&self) -> Color {
        self.accent.dim(1.2)  // 20% brighter
    }
}
```

---

## Animation System

**Terminal constraints:**
- Character grid (no sub-cell positioning)
- ~60fps max practical
- But: Smooth color interpolation works great!

### Frame Timing (Dynamic Mode Switching)

**Two rendering modes:**

1. **Event-Driven (Default - 0% CPU)**
   - Runtime blocks waiting for events
   - No rendering until event arrives
   - Perfect for battery life

2. **Frame-Driven (Only When Animating)**
   - Runtime renders at 60fps
   - Switches automatically when animations active
   - Back to event-driven when animations complete

```rust
impl Runtime {
    async fn run(&mut self) {
        loop {
            // Check if any animations are active
            let animating = self.has_active_animations();

            if animating {
                // FRAME-DRIVEN: Render at 60fps
                tokio::select! {
                    Some(event) = self.events.recv() => {
                        self.handle_event(event);
                    }
                    _ = tokio::time::sleep(Duration::from_millis(16)) => {
                        // Time for next animation frame
                    }
                }

                self.render();  // Interpolate next frame

            } else {
                // EVENT-DRIVEN: Block until event (could be minutes!)
                let event = self.events.recv().await;  // BLOCKS - 0% CPU
                self.handle_event(event);

                self.render();  // Render once
            }
        }
    }

    fn has_active_animations(&self) -> bool {
        self.toast_manager.has_animations() ||
        self.animation_manager.has_active()
    }
}
```

**CPU impact:**
- Idle app: **0% CPU** (thread blocked on event)
- Animating: **~1-2% CPU** (60fps Ã— minimal work)
- Switches automatically - no user intervention

### Toast System (Global)

**Managed by framework, not apps:**

```rust
// Apps just call methods
async fn handle_save(&mut self, ctx: &mut Context) {
    match self.save().await {
        Ok(_) => ctx.toast.success("Saved!"),
        Err(e) => ctx.toast.error(format!("Failed: {}", e)),
    }
}

// Runtime automatically adds toast layer
impl Runtime {
    fn render(&mut self) {
        let mut all_layers = vec![];

        all_layers.push(Layer::dock_top(3, self.render_header()));
        all_layers.extend(self.active_app.update());

        // System-managed toast layer (not app-managed!)
        if let Some(toast_layer) = self.toast_manager.render() {
            all_layers.push(toast_layer);
        }

        self.renderer.render(&all_layers);
    }
}
```

**Toast animations:**

```rust
struct Toast {
    message: String,
    level: ToastLevel,
    created: Instant,
    state: ToastState,
}

enum ToastState {
    Entering,   // Sliding in from right
    Visible,    // Fully visible
    Exiting,    // Fading out
}

fn render_toast(&self, toast: &Toast) -> Element {
    let age = Instant::now().duration_since(toast.created);

    // Calculate animation values
    let (offset_y, alpha) = match toast.state {
        ToastState::Entering => {
            let t = (age.as_secs_f32() / 0.2).clamp(0.0, 1.0);
            let eased = 1.0 - (1.0 - t).powi(3);  // EaseOut
            (((1.0 - eased) * 3.0) as i16, eased)
        }
        ToastState::Visible => (0, 1.0),
        ToastState::Exiting => {
            let t = (age.as_secs_f32() / 0.3).clamp(0.0, 1.0);
            (0, 1.0 - t)
        }
    };

    // Fade colors based on alpha
    let fg = toast_color.fade(&theme.bg_base, alpha);
    let bg = theme.bg_surface.fade(&theme.bg_base, alpha * 0.9);

    panel(&toast.message)
        .style(Style::fg(fg.to_rgb()).bg(bg.to_rgb()))
        .offset_y(offset_y)
}
```

**Toast API:**

```rust
// Simple usage
ctx.toast.info("Loading...");
ctx.toast.success("Done!");
ctx.toast.warning("Check this");
ctx.toast.error("Failed!");

// Custom duration
ctx.toast.info("Quick message").duration(Duration::from_secs(1));

// With action button
ctx.toast.info("File saved")
    .action("Undo", Self::handle_undo);
```

### Drag & Drop

```rust
struct DragState {
    dragging: Option<DragData>,
    current_pos: (u16, u16),
}

struct DragData {
    item_index: usize,
    item_snapshot: Element,
}

impl App for MyApp {
    fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
        let mut layers = vec![
            Layer::fill(panel("Items", |ui| {
                ui.list(&mut self.list_state, &self.items)
                    .draggable(true)
                    .on_drag_start(|idx| {
                        self.drag_state.start_drag(idx, &self.items[idx]);
                    })
                    .on_drop(|from_idx, to_idx| {
                        self.items.swap(from_idx, to_idx);
                    });
            }))
        ];

        // Dragged item as overlay layer
        if let Some(drag) = &self.drag_state.dragging {
            layers.push(
                Layer::at(self.drag_state.current_pos, drag.item_snapshot.clone())
                    .alpha(0.8)  // Semi-transparent
            );
        }

        layers
    }
}
```

### Animation Easing

```rust
enum Easing {
    Linear,
    EaseOut,          // Decelerate (feels natural)
    EaseInOut,        // S-curve
    Spring(f32),      // Bouncy (damping factor)
}

impl Easing {
    fn apply(&self, t: f32) -> f32 {
        match self {
            Easing::Linear => t,
            Easing::EaseOut => 1.0 - (1.0 - t).powi(3),
            Easing::EaseInOut => {
                if t < 0.5 {
                    4.0 * t * t * t
                } else {
                    1.0 - (-2.0 * t + 2.0).powi(3) / 2.0
                }
            }
            Easing::Spring(damping) => {
                1.0 - f32::exp(-damping * t) * (2.0 * PI * 1.5 * t).cos()
            }
        }
    }
}
```

---

## Background Work + Invalidation

Apps can do work while user is idle and trigger UI updates:

```rust
// Pattern 1: Progress updates
async fn process_batch(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();
    let progress = Arc::new(AtomicU32::new(0));
    let progress_clone = progress.clone();

    ctx.spawn(async move {
        for i in 0..100 {
            process_step(i).await;
            progress_clone.store(i, Ordering::Relaxed);
            invalidator.invalidate();  // Trigger re-render
        }
    });

    self.progress = progress;
}

fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    let progress = self.progress.load(Ordering::Relaxed);

    vec![
        Layer::fill(panel("Processing", |ui| {
            ui.progress_bar(progress, 100);
        }))
    ]
}

// Pattern 2: File watching
async fn watch_config(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();

    ctx.spawn(async move {
        let mut watcher = notify::watcher(...);
        while watcher.changed().await {
            invalidator.invalidate();  // File changed, re-render
        }
    });
}

// Pattern 3: Periodic polling
async fn poll_api(&mut self, ctx: &mut Context) {
    let invalidator = ctx.invalidator();

    ctx.spawn(async move {
        loop {
            fetch_and_update().await;
            invalidator.invalidate();
            tokio::time::sleep(Duration::from_secs(5)).await;
        }
    });
}
```

**Event Sources (all wake runtime from sleep):**
- Keyboard/mouse events (OS wakes us, ~1-3ms latency)
- Resource completion (async task finishes)
- Pub/sub messages (from other apps)
- Timers (tokio timers)
- Explicit invalidation (from background tasks)

**Total keypress latency: ~7-11ms** (competitive with native GUIs)

---

## Widget Interaction Patterns

**In immediate mode, widget interaction is dramatically simpler than V1's callback-heavy architecture.**

### V1 Problems (Callback Hell)

**Problem 1: Multiple callback patterns coexisting**

V1 widgets evolved over time, creating inconsistency:

```rust
// TextInput has BOTH old and new patterns
Element::TextInput {
    on_change: Option<fn(KeyCode) -> Msg>,  // Old pattern
    on_submit: Option<Msg>,                  // Old pattern
    on_event: Option<fn(TextInputEvent) -> Msg>,  // New pattern (unified)
    // ...
}

// Select has BOTH too
Element::Select {
    on_select: Option<fn(usize) -> Msg>,    // Old pattern
    on_toggle: Option<Msg>,                  // Old pattern
    on_navigate: Option<fn(KeyCode) -> Msg>, // Old pattern
    on_event: Option<fn(SelectEvent) -> Msg>, // New pattern (unified)
    // ...
}
```

Apps must choose which pattern to use, and renderer has fallback logic:

```rust
let on_key = if let Some(event_handler) = on_event {
    text_input_on_key_event(*event_handler)  // Prefer new
} else {
    text_input_on_key(on_change, on_submit)  // Fall back to old
};
```

**Result**: Confusion about which pattern to use, duplication in framework code.

**Problem 2: on_render callbacks hack**

Scrollable widgets need viewport dimensions to compute scrolling correctly, but dimensions aren't known until render completes:

```rust
// App uses hardcoded fallback
state.list_state.set_viewport_height(20);  // GUESS! Wrong until first render

// Widget requests real dimensions via callback
Element::List {
    on_render: Some(|actual_height| Msg::SetViewportHeight(actual_height)),
    // ...
}

// Renderer calls on_render with actual dimensions
if let Some(render_fn) = on_render {
    registry.add_render_message(render_fn(area.height as usize));
}

// Next frame, app gets real height and updates state
Msg::SetViewportHeight(h) => {
    state.list_state.set_viewport_height(h);
    Command::None
}
```

**Result**: 1-frame delay, hardcoded fallbacks ("20"), boilerplate messages, ~5 lines per scrollable widget.

**Problem 3: Message explosion**

Every widget interaction needs 3-5 Msg enum variants:

```rust
enum Msg {
    SourceTreeNavigate(KeyCode),     // Navigate in tree
    SourceTreeSelect(String),         // Select node
    SourceTreeToggle(String),         // Expand/collapse
    SourceTreeViewportHeight(usize),  // on_render callback
    SourceTreeClicked(String),        // Mouse click

    // Repeat for EVERY widget in your app
    TargetTreeNavigate(KeyCode),
    TargetTreeSelect(String),
    TargetTreeToggle(String),
    TargetTreeViewportHeight(usize),
    TargetTreeClicked(String),

    // ...dozens more
}
```

**Result**: Msg enum bloat, ceremony, hard to maintain.

### V2 Solution: Immediate Mode Events

**Core insight**: In immediate mode, widgets are constructed DURING rendering, so they already know their dimensions. No on_render callbacks needed!

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            // List is constructed during panel render
            // ui knows the panel's allocated area
            // List automatically gets correct viewport dimensions
            ui.list(&mut self.list_state, &self.items);

            // No on_render callback
            // No hardcoded "20" fallback
            // No viewport height message
        }))
    ]
}
```

**Dimension passing is implicit** - framework handles it automatically.

### Interaction Pattern Hierarchy

V2 uses 3 levels of interaction complexity:

#### Level 1: Simple Interactions (Button, Link)

Widgets with single action â†’ `.clicked()` / `.activated()` methods:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Controls", |ui| {
            // Button returns boolean - inline handling
            if ui.button("Save").clicked() {
                self.save();
            }

            if ui.button("Cancel").clicked() {
                ctx.navigate_back();
            }

            // Link (button without border)
            if ui.link("Learn more").clicked() {
                open_browser("https://docs.example.com");
            }
        }))
    ]
}
```

**No messages, no callbacks** - just direct method calls.

### Level 2: Text Input

Single widget with multiple events â†’ inline event checks:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Form", |ui| {
            ui.text_input(&mut self.name);

            // Check submit event
            if ui.events().text_input_submitted() {
                self.submit_form();
            }

            // Value is already updated in self.name.value
            // No on_change callback needed - state mutated directly
        }))
    ]
}
```

**State mutation is immediate** - no message passing for value changes.

#### Level 3: Complex Widgets (List, Tree, Table)

Widgets with many possible events â†’ event enum via `ui.events()`:

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Files", |ui| {
            // List mutates state directly (selection, scrolling)
            ui.list(&mut self.list_state, &self.files);

            // Check events after widget construction
            match ui.events().list() {
                Some(ListEvent::Selected(idx)) => {
                    // Single-click - update preview
                    self.preview_file(idx);
                }
                Some(ListEvent::Activated(idx)) => {
                    // Double-click or Enter - open file
                    self.open_file(idx);
                }
                Some(ListEvent::RightClick(idx)) => {
                    // Show context menu
                    self.show_context_menu = true;
                    self.context_menu_target = idx;
                    self.context_menu_pos = ctx.mouse.position();
                }
                None => {}
            }
        }))
    ]
}
```

**Event enums are clean:**

```rust
pub enum ListEvent {
    Selected(usize),        // Arrow key or single-click
    Activated(usize),       // Enter or double-click
    RightClick(usize),      // Right-click for context menu
}

pub enum TreeEvent {
    Selected(String),       // Node selected (ID-based, not index)
    Toggled(String),        // Node expanded/collapsed
    RightClick(String),     // Right-click on node
}

pub enum TableEvent {
    CellSelected(usize, usize),  // (row, col)
    CellActivated(usize, usize),
    ColumnResized(usize, u16),   // (col, new_width)
}
```

**Pattern consistency:**
- **Selected** = navigation (arrow keys, single-click)
- **Activated** = action (Enter, double-click)
- **RightClick** = context menu

### Events API

Framework provides `ui.events()` accessor for checking widget events:

```rust
impl UiBuilder {
    pub fn events(&self) -> &EventRegistry;
}

struct EventRegistry {
    list_events: Option<ListEvent>,
    tree_events: Option<TreeEvent>,
    table_events: Option<TableEvent>,
    text_input_submitted: bool,
    // ...
}

impl EventRegistry {
    // Widget-specific accessors
    pub fn list(&self) -> Option<ListEvent> {
        self.list_events.clone()
    }

    pub fn tree(&self) -> Option<TreeEvent> {
        self.tree_events.clone()
    }

    pub fn table(&self) -> Option<TableEvent> {
        self.table_events.clone()
    }

    pub fn text_input_submitted(&self) -> bool {
        self.text_input_submitted
    }
}
```

**Key design decisions:**

1. **Widget-specific methods** - not `events().get::<ListEvent>()` (too generic)
2. **Option for single-event widgets** - list returns `Option<ListEvent>`
3. **Boolean for simple flags** - text_input_submitted() returns `bool`
4. **Clone events** - apps can store events for next frame if needed

### Widget State Mutation

**V1 problem**: App must manually update widget state based on callbacks:

```rust
// V1 - manual state management
Msg::ListNavigate(key) => {
    match key {
        KeyCode::Up => state.list_state.navigate_up(),
        KeyCode::Down => state.list_state.navigate_down(),
        // ...
    }
    Command::None
}
```

**V2 solution**: Widgets mutate their state automatically:

```rust
// V2 - automatic state management
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Items", |ui| {
            // List handles arrow keys internally, updates self.list_state
            ui.list(&mut self.list_state, &self.items);

            // App only handles semantic events (activate, right-click)
            if let Some(ListEvent::Activated(idx)) = ui.events().list() {
                self.open_item(idx);
            }
        }))
    ]
}
```

**Automatic behaviors** (no app code needed):
- Arrow keys update selection
- Scroll wheel updates scroll offset
- PageUp/PageDown navigate by page
- Home/End jump to start/end
- Tab/Shift-Tab move focus
- Escape blurs focus

**Manual only for semantic actions** (open, delete, context menu, etc.)

### Multi-Widget Events

Apps with multiple lists/trees need to differentiate events:

**Pattern 1: Separate calls to ui.events()**

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Split View", |ui| {
            ui.list(&mut self.source_list, &self.source_items);
            let source_event = ui.events().list();  // Get event BEFORE next widget

            ui.list(&mut self.target_list, &self.target_items);
            let target_event = ui.events().list();  // Get event for second list

            if let Some(ListEvent::Activated(idx)) = source_event {
                self.handle_source_activated(idx);
            }

            if let Some(ListEvent::Activated(idx)) = target_event {
                self.handle_target_activated(idx);
            }
        }))
    ]
}
```

**Pattern 2: ID-based event filtering**

```rust
fn update(&mut self, ctx: &mut Context) -> Vec<Layer> {
    vec![
        Layer::fill(panel("Split View", |ui| {
            ui.list(&mut self.source_list, &self.source_items).id("source");
            ui.list(&mut self.target_list, &self.target_items).id("target");

            // Events include widget ID
            match ui.events().list_by_id("source") {
                Some(ListEvent::Activated(idx)) => self.handle_source_activated(idx),
                _ => {}
            }

            match ui.events().list_by_id("target") {
                Some(ListEvent::Activated(idx)) => self.handle_target_activated(idx),
                _ => {}
            }
        }))
    ]
}
```

**Framework tracks last widget of each type** - calling `ui.list()` twice registers two separate event sources.

### Keybind Integration

**Problem**: Widgets handle navigation keys (arrows, PageUp/Down) automatically. What about app keybinds?

**Solution**: Keybind priority system:

1. **Focused widget** gets first chance at key
2. **Widget refuses** â†’ App keybinds checked
3. **App doesn't handle** â†’ Global keybinds (Ctrl+Space, F1, etc.)

```rust
impl Runtime {
    fn handle_key(&mut self, key: KeyCode) {
        // 1. Give focused widget first chance
        if let Some(focused) = self.focus.focused_widget() {
            if focused.handle_key(key) {
                return;  // Widget consumed the key
            }
        }

        // 2. Check app keybinds
        if let Some(action) = self.active_app.keybinds().get(key) {
            action.call(&mut self.active_app);
            return;
        }

        // 3. Check global keybinds
        if let Some(global) = self.global_keybinds.get(key) {
            global.call();
            return;
        }

        // 4. Ignore unhandled key
    }
}
```

**Widgets only consume navigation keys** - letter keys, Ctrl+keys, etc. pass through to app.

### Benefits

âœ… **No on_render callbacks** - widgets know dimensions immediately
âœ… **No message explosion** - events handled inline, not via Msg enum
âœ… **No callback confusion** - single event pattern (inline checks)
âœ… **Automatic state management** - widgets handle navigation internally
âœ… **Simple interactions are trivial** - `if ui.button("Save").clicked()`
âœ… **Complex interactions stay clean** - event enums with match
âœ… **Type-safe** - compiler catches mismatched event types
âœ… **No boilerplate** - ~90% less code compared to V1

### Migration from V1

**V1 Button with callback:**
```rust
// V1
Element::button(id, "Save")
    .on_press(Msg::Save)
    .build()

// V2
if ui.button("Save").clicked() {
    self.save();
}
```

**V1 List with multiple callbacks:**
```rust
// V1 (5 callbacks + 5 Msg variants)
Element::list(id, items, state)
    .on_select(Msg::ListSelect)
    .on_activate(Msg::ListActivate)
    .on_navigate(Msg::ListNavigate)
    .on_render(Msg::ListViewportHeight)
    .build()

enum Msg {
    ListSelect(usize),
    ListActivate(usize),
    ListNavigate(KeyCode),
    ListViewportHeight(usize),
}

// V2 (single event check, no messages)
ui.list(&mut self.list_state, &self.items);

if let Some(ListEvent::Activated(idx)) = ui.events().list() {
    self.open_item(idx);
}
```

**V1 TextInput with value tracking:**
```rust
// V1 (manual state updates)
Element::text_input(id, &state.value, &state.input_state)
    .on_event(Msg::InputEvent)
    .build()

Msg::InputEvent(event) => {
    if let Some(new_value) = state.input_field.handle_event(event, None) {
        state.value = new_value;
    }
    Command::None
}

// V2 (automatic state updates)
ui.text_input(&mut self.input);  // input is TextInputField

if ui.events().text_input_submitted() {
    self.submit(self.input.value());
}
```

---

## TBD - V1 Features Not Yet Discussed

### Widget-Specific Features

- **Tree Widget**: expansion/collapse state, scrolloff, parent navigation (left arrow jumps to parent), table-tree variant with columns/borders, cached metadata (node_parents, node_depths, visible_order)
- **File Browser**: filtering (show only specific file types), directory navigation with `..` support, file/directory icons
- **Color Picker**: HSL/RGB/Hex modes, channel-based navigation (Tab/Shift-Tab), live preview, shift+arrows for 10x adjustment
- **Autocomplete**: fuzzy matching with SkimMatcherV2, top 15 results, auto-open/close dropdown, highlight navigation
- **Text Input**: password masking, placeholder text, max length validation, cursor/scroll management
- **List/Tree Scrolloff**: vim-style scrolloff (keeps N lines between cursor and edge before scrolling)

### Layout & Macros

- **Layout macros**: `col!`, `row!`, `spacer!`, `button_row!`, `modal!`
- **Form builder DSL**: `form_layout!` macro (reduces form code by ~60%)
- **Labeled inputs**: `labeled_input!` macro
- **Subscriptions DSL**: `subscriptions!` macro with `key!`, `timer!`, `event!`, `when` blocks

### Theme System

- **Theme variants**: Mocha (dark), Latte (light)
- **21 semantic colors**: 8 accents, 3 text levels, 6 UI structure, 4 flexible palette
- **Helper styles**: error_style(), warning_style(), success_style(), info_style(), link_style(), cursor_style()
- **Color iteration**: `theme.colors()` returns all colors as (name, color) pairs

### Widget Field Pattern

- **Field types**: AutocompleteField, TextInputField, SelectField (combine value + state in one field)
- **Event aggregation**: reduces boilerplate by ~80% (5 fields â†’ 1 field per widget)
- **Unified event handlers**: single event enum per widget type

### Multi-Runtime Features

- **App launcher**: Ctrl+Space brings up app switcher
- **Global keybindings**: F1 (help), Ctrl+Space (launcher), Esc (progressive unfocus/quit)
- **Context-aware help**: F1 shows keybindings for current app + global + other apps

### Container Features

- **Panel**: title, explicit width/height, auto-sizing (+2 lines for borders)
- **Container**: configurable padding
- **Stack**: multiple layers with alignment (Center, TopLeft, etc.) and dim_below option

### Alignment & Positioning

- **9 alignment options**: Center, TopLeft, TopCenter, TopRight, BottomLeft, BottomCenter, BottomRight, etc.
- **Dim below**: layer option to dim everything below it

### Constraints System

- **LayoutConstraint**: Length (fixed), Min (minimum), Fill (proportional)
- **Auto-constraints**: each element type has default_constraint() method
- **Macro shorthand**: `use_constraints!()` imports Fill, Length, Min for shorter syntax

---

## Open Questions / TODO

- [ ] How to handle widget-specific nav overrides (vim keys for list)?
- [ ] Conditional keybinds (different keys when modal open)?
- [ ] Keybind conflict resolution UI
- [ ] Resource progress tracking (0-100%)?
- [ ] Error recovery patterns for async?
- [ ] Performance - how much does immediate mode cost vs declarative?
- [ ] Testing strategy - can we test without terminal?
- [ ] Migration path from v1 (if any)?
- [ ] Theme/styling system (current catppuccin is good, keep it?)
- [ ] Layout builder improvements (current macros are fine?)

---

## Non-Goals

- **V1 Compatibility** - Clean slate, rewrite apps
- **Complex Animations** - Terminal UIs don't need smooth transitions
- **Web/GUI Support** - TUI only, don't over-abstract
- **Time-Travel Debug** - Nice to have but not priority

---

## Next Steps

1. Continue brainstorming edge cases
2. Prototype core abstractions (Context, Layer, Resource)
3. Build 1-2 example apps to validate API
4. Iterate on ergonomics
5. Implementation plan (separate from this doc)
